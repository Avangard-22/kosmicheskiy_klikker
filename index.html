<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>–ö–æ—Å–º–∏—á–µ—Å–∫–∏–π –ö–ª–∏–∫–µ—Ä</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <style>
    * {
      box-sizing: border-box;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    body {
      font-family: 'Orbitron', 'Segoe UI', sans-serif;
      margin: 0;
      padding: 0;
      overflow: hidden;
      position: relative;
      background: #000;
      width: 100vw;
      height: 100vh;
    }
    /* Canvas –¥–ª—è –ø–ª–∞–Ω–µ—Ç–∞—Ä–Ω–æ–≥–æ —Ñ–æ–Ω–∞ */
    #planetBackgroundCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    /* –ú–æ–±–∏–ª—å–Ω–∞—è –∞–¥–∞–ø—Ç–∞—Ü–∏—è UI */
    #header {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      text-align: center;
      z-index: 20;
      padding: 8px 50px 8px 0;
      backdrop-filter: blur(6px);
      border-bottom: 1px solid;
      background: rgba(0, 0, 0, 0.5);
    }
    #gameTitle { 
      margin: 0; 
      font-size: clamp(1.1em, 4vw, 1.4em); 
      color: white;
    }
    /* –û–ë–ù–û–í–õ–ï–ù–ù–û–ï –†–ê–°–ü–û–õ–û–ñ–ï–ù–ò–ï HUD - –í–ù–ò–ó–£ –°–õ–ï–í–ê */
    #hud-left {
      position: absolute;
      bottom: 10px;
      left: 10px;
      z-index: 25;
      display: flex;
      flex-direction: column;
      gap: 3px;
      background: rgba(0, 0, 0, 0.6);
      padding: 8px 12px;
      border-radius: 8px;
      backdrop-filter: blur(4px);
      border: 1px solid rgba(255,255,255,0.1);
    }
    .hud-item {
      font-size: clamp(0.7em, 3vw, 0.8em);
      display: flex;
      align-items: center;
      gap: 6px;
      color: white;
      white-space: nowrap;
    }
    .hud-item i {
      width: 20px;
      text-align: center;
    }
    .hud-item#coins { color: #FFD54F; text-shadow: 0 0 4px rgba(255,213,79,0.6); }
    .hud-item#clickPowerInfo { color: #4FC3F7; text-shadow: 0 0 4px rgba(79,195,247,0.6); }
    .hud-item#critChanceInfo, .hud-item#critMultiplierInfo { color: #FFD700; text-shadow: 0 0 4px rgba(255,215,0,0.6); }
    /* –ü–†–û–ì–†–ï–°–°-–ë–ê–† –í –¶–ï–ù–¢–†–ï –ü–û–î –ù–ê–ó–í–ê–ù–ò–ï–ú –õ–û–ö–ê–¶–ò–ò */
    #progressContainer {
      position: absolute;
      top: 45px;
      left: 50%;
      transform: translateX(-50%);
      width: min(90%, 400px);
      height: 8px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      overflow: hidden;
      z-index: 25;
    }
    #progressText {
      position: absolute;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-size: clamp(0.6em, 2.5vw, 0.7em);
      color: #a0d2ff;
      text-shadow: 0 0 3px rgba(160,210,255,0.6);
      z-index: 25;
      text-align: center;
      width: min(90%, 400px);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    /* –ö–Ω–æ–ø–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è */
    #saveBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 40px;
      height: 40px;
      border: none;
      border-radius: 8px;
      font-size: 1.2em;
      cursor: pointer;
      z-index: 30;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.5);
      color: #4CAF50;
      transition: transform 0.1s;
    }
    #saveBtn:active { transform: scale(0.92); }
    /* –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –∫–Ω–æ–ø–∫–∏ —É–ª—É—á—à–µ–Ω–∏–π */
    .upgrade-btn {
      position: absolute;
      right: 10px;
      width: clamp(48px, 12vw, 52px);
      height: clamp(48px, 12vw, 52px);
      border: none;
      border-radius: 8px;
      font-size: clamp(1.1em, 4vw, 1.3em);
      cursor: pointer;
      z-index: 30;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: transform 0.1s;
      box-shadow: 0 3px 6px rgba(0,0,0,0.3);
      padding: 3px;
      overflow: hidden;
    }
    .upgrade-btn:active { transform: scale(0.92); }
    #upgradeClickBtn { bottom: 75px; }
    #upgradeHelperBtn { bottom: 135px; }
    #upgradeCritChanceBtn { bottom: 195px; }
    #upgradeCritMultBtn { bottom: 255px; }
    #upgradeHelperDmgBtn { bottom: 315px; }
    .upgrade-cost {
      font-size: clamp(0.5em, 2.5vw, 0.55em);
      margin-top: 1px;
      font-weight: bold;
      text-shadow: 0 0 2px rgba(0,0,0,0.8);
    }
    /* –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –±–ª–æ–∫–∏ */
    .moving-block {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
      font-weight: bold;
      font-size: clamp(0.8em, 4vw, 0.9em);
      font-family: 'Orbitron', monospace;
      transition: transform 0.1s;
      color: white;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
      overflow: hidden;
      min-width: 60px;
      min-height: 60px;
    }
    /* –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ —ç–∫—Ä–∞–Ω—ã */
    #welcomeScreen, #gameOverScreen, #saveScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      color: white;
      text-align: center;
      padding: 15px;
      box-sizing: border-box;
    }
    #welcomeScreen h2 {
      font-size: clamp(1.5em, 6vw, 2em);
      margin-bottom: 15px;
    }
    #welcomeScreen p {
      max-width: 95%;
      text-align: center;
      margin: 8px 0;
      line-height: 1.4;
      font-size: clamp(0.9em, 3.5vw, 1em);
    }
    .btn {
      padding: clamp(10px, 3vw, 12px) clamp(25px, 6vw, 30px);
      margin-top: 15px;
      font-size: clamp(1em, 4vw, 1.1em);
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
      transition: transform 0.1s;
      min-height: 44px; /* –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –¥–ª—è –∫–∞—Å–∞–Ω–∏—è */
    }
    #continueBtn {
      background: #2196F3;
      margin-bottom: 10px;
    }
    #continueBtn.save-available {
      background: #4CAF50;
    }
    #continueBtn.no-save {
      background: #f44336;
    }
    #gameOverScreen h2 {
      font-size: clamp(1.6em, 6vw, 2.2em);
      margin-bottom: 15px;
    }
    #finalScore { font-size: clamp(1.1em, 4vw, 1.4em); margin-bottom: 15px; }
    #restartBtn, #shareBtn {
      padding: clamp(8px, 2.5vw, 10px) clamp(20px, 5vw, 24px);
      margin: 6px;
      font-size: clamp(0.9em, 3.5vw, 1em);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
      transition: transform 0.1s;
      min-height: 44px;
    }
    /* –≠–∫—Ä–∞–Ω —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è */
    #saveScreen {
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(10px);
      display: none;
    }
    #saveScreen h2 {
      font-size: clamp(1.5em, 6vw, 2em);
      margin-bottom: 20px;
    }
    #saveScreen p {
      max-width: 90%;
      margin-bottom: 20px;
      line-height: 1.5;
    }
    /* –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ —Ç–µ–∫—Å—Ç—ã —É—Ä–æ–Ω–∞ - –û–ë–ù–û–í–õ–ï–ù–û: —É–ª—É—á—à–µ–Ω–∞ —á–∏—Ç–∞–µ–º–æ—Å—Ç—å */
    .damage-text {
      font-size: clamp(1em, 4vw, 1.1em);
      position: absolute;
      pointer-events: none;
      z-index: 15;
      opacity: 1;
      transition: transform 0.5s, opacity 0.5s;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px rgba(0,0,0,0.9);
      max-width: 100px;
      text-align: center;
      font-weight: bold;
      color: #FFFFFF;
      -webkit-text-stroke: 1px #000000;
    }
    .combo-text {
      font-size: clamp(1.4em, 5vw, 1.8em);
      position: absolute;
      pointer-events: none;
      z-index: 15;
      animation: comboPop 0.5s ease-out;
      font-family: 'Orbitron', monospace;
      max-width: 150px;
      text-align: center;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px rgba(0,0,0,0.9);
      font-weight: bold;
      color: #FFD700;
      -webkit-text-stroke: 1px #000000;
    }
    .reward-text {
      font-size: clamp(1.1em, 4vw, 1.3em);
      position: absolute;
      pointer-events: none;
      z-index: 15;
      animation: rewardFloat 1.5s ease-out;
      font-family: 'Orbitron', monospace;
      max-width: 120px;
      text-align: center;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px rgba(0,0,0,0.9);
      font-weight: bold;
      color: #FFFFFF;
      -webkit-text-stroke: 1px #000000;
    }
    /* –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è landscape —Ä–µ–∂–∏–º–∞ */
    @media (max-height: 500px) and (orientation: landscape) {
      #header {
        padding: 4px 40px 4px 0;
      }
      #hud-left {
        bottom: 8px;
        left: 8px;
        gap: 2px;
      }
      .upgrade-btn {
        width: 40px;
        height: 40px;
        right: 8px;
      }
      #upgradeClickBtn { bottom: 60px; }
      #upgradeHelperBtn { bottom: 110px; }
      #upgradeCritChanceBtn { bottom: 160px; }
      #upgradeCritMultBtn { bottom: 210px; }
      #upgradeHelperDmgBtn { bottom: 260px; }
      #progressContainer {
        top: 35px;
        height: 6px;
      }
      #progressText {
        top: 48px;
        font-size: 0.6em;
      }
    }
    /* –û—Å—Ç–∞–ª—å–Ω—ã–µ —Å—Ç–∏–ª–∏ */
    #progressBar {
      height: 100%;
      background: linear-gradient(90deg, #bb86fc, #4a55e0);
      border-radius: 4px;
      width: 0%;
      transition: width 0.3s ease;
    }
    #gameArea {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      z-index: 5;
    }
    .crack-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background-image: 
        radial-gradient(circle at 30% 30%, transparent 60%, rgba(0,0,0,0.3) 65%),
        radial-gradient(circle at 70% 70%, transparent 60%, rgba(0,0,0,0.3) 65%),
        radial-gradient(circle at 50% 20%, transparent 60%, rgba(0,0,0,0.3) 65%);
      opacity: 0;
      transition: opacity 0.3s;
    }
    .crack-1 { opacity: 0.3; }
    .crack-2 { opacity: 0.6; }
    .crack-3 { opacity: 0.9; }
    #levelAnnounce {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: clamp(1.2em, 5vw, 1.5em);
      font-weight: bold;
      z-index: 40;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
      font-family: 'Orbitron', sans-serif;
      text-align: center;
      color: white;
      text-shadow: 0 0 10px rgba(0,0,0,0.8);
    }
    .upgrade-btn.btn-available { 
      background: linear-gradient(135deg, #4CAF50, #388E3C); 
      color: white; 
    }
    .upgrade-btn.btn-unavailable { 
      background: linear-gradient(135deg, #666, #444); 
      color: #ccc; 
      cursor: not-allowed; 
      opacity: 0.7;
    }
    .tooltip {
      position: absolute;
      bottom: 70px;
      right: 15px;
      padding: 5px 8px;
      border-radius: 6px;
      font-size: clamp(0.75em, 3vw, 0.85em);
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      z-index: 35;
    }
    #particlesCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 6;
    }
    @keyframes comboPop {
      0% { transform: scale(0.5); opacity: 0; }
      70% { transform: scale(1.2); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
    @keyframes rewardFloat {
      0% { transform: translateY(0); opacity: 1; }
      100% { transform: translateY(-50px); opacity: 0; }
    }
    .helper {
      position: absolute;
      width: 35px;
      height: 35px;
      background: radial-gradient(circle, #69f0ae, #00e676);
      border-radius: 50%;
      z-index: 12;
      pointer-events: none;
      box-shadow: 0 0 15px #69f0ae;
      animation: helperFloat 3s ease-in-out infinite;
    }
    @keyframes helperFloat {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-10px); }
    }
    /* –í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –ª—É—á–∞ Bobo */
    .helper-beam {
      position: absolute;
      z-index: 13;
      pointer-events: none;
    }
    #welcomeScreen { 
      background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
    }
    #gameOverScreen {
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(5px);
      display: none;
    }
    #restartBtn { background: #4CAF50; color: white; }
    #shareBtn { background: #00c853; color: white; }
    /* –°—Ç–∏–ª–∏ –¥–ª—è —Ä–µ–¥–∫–∏—Ö –±–ª–æ–∫–æ–≤ */
    .block-gold {
        background: linear-gradient(135deg, #ffd700, #ff6b00) !important;
        animation: gold-shimmer 3s infinite;
    }
    .block-rainbow {
        background: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #00ffff, #0000ff, #8b00ff) !important;
        background-size: 400% 400%;
        animation: rainbow 3s ease infinite;
    }
    .block-crystal {
        background: linear-gradient(45deg, #00ffff, #ffffff, #00ffff) !important;
        box-shadow: 0 0 25px #00ffff, 0 0 10px #ffffff inset !important;
        animation: crystalPulse 2s ease-in-out infinite !important;
    }
    .block-mystery {
        background: linear-gradient(45deg, #9b59b6, #e74c3c, #3498db) !important;
        background-size: 300% 300% !important;
        box-shadow: 0 0 20px rgba(155, 89, 182, 0.7) !important;
        animation: mysteryShift 4s ease-in-out infinite !important;
    }
    /* –û–ë–ù–û–í–õ–ï–ù–ù–´–ï –°–¢–ò–õ–ò –î–õ–Ø –≠–§–§–ï–ö–¢–ê –í–ó–†–´–í–ê - –£–í–ï–õ–ò–ß–ï–ù–ù–ê–Ø –û–ë–õ–ê–°–¢–¨ */
    .explosion {
      position: absolute;
      pointer-events: none;
      z-index: 15;
      width: 200px;
      height: 200px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0) 70%);
      transform: translate(-50%, -50%);
      animation: explode 0.6s ease-out forwards;
    }
    @keyframes explode {
      0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 1;
      }
      50% {
        opacity: 0.8;
      }
      100% {
        transform: translate(-50%, -50%) scale(2.5);
        opacity: 0;
      }
    }
    .explosion-particle {
      position: absolute;
      pointer-events: none;
      z-index: 14;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      animation: particleFly 0.8s ease-out forwards;
    }
    @keyframes particleFly {
      0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
      }
      100% {
        transform: translate(var(--tx), var(--ty)) scale(0);
        opacity: 0;
      }
    }
    /* –ê–¥–∞–ø—Ç–∞—Ü–∏—è –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤ */
    @media (max-width: 768px) {
      .explosion {
        width: 150px;
        height: 150px;
      }
      .explosion-particle {
        width: 10px;
        height: 10px;
      }
    }
    @keyframes gold-shimmer {
        0% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5), 0 0 5px rgba(255, 107, 0, 0.3) inset; }
        50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 10px rgba(255, 107, 0, 0.6) inset; }
        100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5), 0 0 5px rgba(255, 107, 0, 0.3) inset; }
    }
    @keyframes rainbow {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }
    @keyframes crystalPulse {
        0%, 100% { transform: translateX(-50%) scale(1); }
        50% { transform: translateX(-50%) scale(1.05); }
    }
    @keyframes mysteryShift {
        0%, 100% { background-position: 0% 50%; filter: hue-rotate(0deg); }
        50% { background-position: 100% 50%; filter: hue-rotate(180deg); }
    }
    /* –ö–Ω–æ–ø–∫–∞ –≤—ã–±–æ—Ä–∞ —è–∑—ã–∫–∞ –Ω–∞ —ç–∫—Ä–∞–Ω–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏—è */
    #langBtn-welcome {
      position: absolute;
      top: 15px;
      right: 15px;
      width: 40px;
      height: 40px;
      border: none;
      border-radius: 8px;
      font-size: 1.5em;
      cursor: pointer;
      z-index: 35;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      transition: transform 0.1s;
    }
    #langBtn-welcome:active { transform: scale(0.92); }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
  <!-- Canvas –¥–ª—è –ø–ª–∞–Ω–µ—Ç–∞—Ä–Ω–æ–≥–æ —Ñ–æ–Ω–∞ -->
  <canvas id="planetBackgroundCanvas"></canvas>
  <!-- UI -->
  <div id="header">
    <h2 id="gameTitle">‚òø –ú–µ—Ä–∫—É—Ä–∏–π</h2>
  </div>
  <!-- –ö–Ω–æ–ø–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è -->
  <button id="saveBtn" title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–≥—Ä—É">
    <i class="fas fa-save"></i>
  </button>
  <!-- –û–ë–ù–û–í–õ–ï–ù–ù–´–ô HUD - –í–ù–ò–ó–£ –°–õ–ï–í–ê, –ë–ï–ó –ò–ù–§–û–†–ú–ê–¶–ò–ò –û BOBO -->
  <div id="hud-left">
    <div class="hud-item" id="coins"><i class="fas fa-gem"></i> –ö—Ä–∏—Å—Ç–∞–ª–ª—ã: <span id="coins-value">0</span></div>
    <div class="hud-item" id="clickPowerInfo"><i class="fas fa-fist-raised"></i> –°–∏–ª–∞: <span id="clickPower-value">1</span></div>
    <div class="hud-item" id="critChanceInfo"><i class="fas fa-star"></i> –ö—Ä–∏—Ç: <span id="critChance-value">0.1%</span></div>
    <div class="hud-item" id="critMultiplierInfo"><i class="fas fa-star"></i> –ú–Ω–æ–∂: <span id="critMultiplier-value">x2.0</span></div>
  </div>
  <!-- –ü–†–û–ì–†–ï–°–°-–ë–ê–† –í –¶–ï–ù–¢–†–ï –ü–û–î –ù–ê–ó–í–ê–ù–ò–ï–ú –õ–û–ö–ê–¶–ò–ò -->
  <div id="progressContainer">
    <div id="progressBar"></div>
  </div>
  <div id="progressText">–ü—Ä–æ–≥—Ä–µ—Å—Å: 0.00000 / 0.38710 –∞.–µ. (0%)</div>
  <div id="gameArea"></div>
  <div id="levelAnnounce"></div>
  <!-- –ö–ù–û–ü–ö–ò –£–õ–£–ß–®–ï–ù–ò–ô -->
  <button id="upgradeClickBtn" class="upgrade-btn btn-unavailable">
    <i class="fas fa-fist-raised"></i>
    <div class="upgrade-cost">80</div>
  </button>
  <button id="upgradeHelperBtn" class="upgrade-btn btn-unavailable">
    <i class="fas fa-robot"></i>
    <div class="upgrade-cost">1500</div>
  </button>
  <button id="upgradeCritChanceBtn" class="upgrade-btn btn-unavailable">
    <i class="fas fa-star"></i>
    <div class="upgrade-cost">500</div>
  </button>
  <button id="upgradeCritMultBtn" class="upgrade-btn btn-unavailable">
    <i class="fas fa-star"></i>
    <div class="upgrade-cost">800</div>
  </button>
  <button id="upgradeHelperDmgBtn" class="upgrade-btn btn-unavailable">
    <i class="fas fa-bolt"></i>
    <div class="upgrade-cost">1000</div>
  </button>
  <div id="tooltip" class="tooltip"></div>
  <canvas id="particlesCanvas"></canvas>
  <!-- –ó–≤—É–∫–æ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã -->
  <audio id="clickSound" preload="auto">
    <source src="audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav">
  </audio>
  <audio id="breakSound" preload="auto">
    <source src="audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav">
  </audio>
  <audio id="upgradeSound" preload="auto">
    <source src="audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav">
  </audio>
  <audio id="comboSound" preload="auto">
    <source src="audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav">
  </audio>
  <audio id="helperSound" preload="auto">
    <source src="audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav">
  </audio>
  <div id="welcomeScreen">
    <h2>üöÄ –ö–û–°–ú–ò–ß–ï–°–ö–ò–ô –ö–õ–ò–ö–ï–†</h2>
    <p>–†–∞–∑—Ä—É—à–∞–π—Ç–µ –≤–æ—Å—Ö–æ–¥—è—â–∏–µ –±–ª–æ–∫–∏ –∏ —Å–æ–±–∏—Ä–∞–π—Ç–µ <strong>–∫–æ—Å–º–∏—á–µ—Å–∫–∏–µ –ö—Ä–∏—Å—Ç–∞–ª–ª—ã</strong>!</p>
    <p>–ö–∞–∂–¥—ã–π –±–ª–æ–∫ —Ç—Ä–µ–±—É–µ—Ç –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —É–¥–∞—Ä–æ–≤ –¥–ª—è —Ä–∞–∑—Ä—É—à–µ–Ω–∏—è.</p>
    <p><strong>–†–µ–∞–ª–∏—Å—Ç–∏—á–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞:</strong></p>
    <p>üåå <strong>–ê—Å—Ç—Ä–æ–Ω–æ–º–∏—á–µ—Å–∫–∏–µ –µ–¥–∏–Ω–∏—Ü—ã</strong> ‚Äî –ø–µ—Ä–µ–º–µ—â–∞–π—Ç–µ—Å—å –ø–æ –°–æ–ª–Ω–µ—á–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ</p>
    <p>ü™ê <strong>9 —Ä–µ–∞–ª—å–Ω—ã—Ö –ø–ª–∞–Ω–µ—Ç</strong> ‚Äî –æ—Ç –ú–µ—Ä–∫—É—Ä–∏—è –¥–æ –ü–ª—É—Ç–æ–Ω–∞</p>
    <p>üöÄ <strong>–£–ª—É—á—à–µ–Ω–∏—è</strong> ‚Äî —É–≤–µ–ª–∏—á–∏–≤–∞–π—Ç–µ —Å–∏–ª—É, –∫—Ä–∏—Ç—ã –∏ –∞–∫—Ç–∏–≤–∏—Ä—É–π—Ç–µ –ø–æ–º–æ—â–Ω–∏–∫–∞</p>
    <p>‚ú® <strong>–†–µ–¥–∫–∏–µ –±–ª–æ–∫–∏</strong> ‚Äî –¥–∞—é—Ç –±–æ–Ω—É—Å—ã –∏ –æ–≥—Ä–æ–º–Ω—ã–µ –Ω–∞–≥—Ä–∞–¥—ã!</p>
    <button id="continueBtn" class="btn no-save">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
    <button id="startBtn" class="btn">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
    <!-- –ö–Ω–æ–ø–∫–∞ –≤—ã–±–æ—Ä–∞ —è–∑—ã–∫–∞ –≤ –ø—Ä–∞–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É —ç–∫—Ä–∞–Ω–∞ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏—è -->
    <button id="langBtn-welcome" title="–°–º–µ–Ω–∏—Ç—å —è–∑—ã–∫">
      <span id="currentLangFlag">üá∑üá∫</span>
    </button>
  </div>
  <!-- –≠–∫—Ä–∞–Ω —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è -->
  <div id="saveScreen">
    <h2>–°–û–•–†–ê–ù–ï–ù–ò–ï –ò–ì–†–´</h2>
    <p>–•–æ—Ç–∏—Ç–µ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–π –∏–≥—Ä—ã –∏–ª–∏ –Ω–∞—á–∞—Ç—å –Ω–æ–≤—É—é?</p>
    <button id="loadSaveBtn" class="btn">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—É—é –∏–≥—Ä—É</button>
    <button id="newGameBtn" class="btn">–ù–∞—á–∞—Ç—å –Ω–æ–≤—É—é –∏–≥—Ä—É</button>
    <button id="cancelSaveBtn" class="btn" style="background: #666;">–û—Ç–º–µ–Ω–∞</button>
  </div>
  <div id="gameOverScreen">
    <h2>–î–û–ë–´–ß–ê –ü–†–ï–†–í–ê–ù–ê!</h2>
    <div id="finalScore">–í—Å–µ–≥–æ —É—Ä–æ–Ω–∞: 0</div>
    <button id="restartBtn">–ù–æ–≤–∞—è –¥–æ–±—ã—á–∞</button>
    <button id="shareBtn">–ü–æ–¥–µ–ª–∏—Ç—å—Å—è</button>
  </div>
  <script>
    // === –û–ë–ù–û–í–õ–ï–ù–ù–´–ô –ö–û–î –ü–õ–ê–ù–ï–¢–ê–†–ù–û–ì–û –§–û–ù–ê –° –≠–§–§–ï–ö–¢–û–ú –ü–ê–†–ê–õ–õ–ê–ö–°–ê ===
    (function() {
      const canvas = document.getElementById('planetBackgroundCanvas');
      const ctx = canvas.getContext('2d');
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      // –ù–ê–°–¢–†–û–ô–ö–ò –ü–ê–†–ê–õ–õ–ê–ö–°–ê
      const parallaxSettings = {
        baseSpeed: 0.2,
        directionX: -1, // –î–≤–∏–∂–µ–Ω–∏–µ –∏–∑ –ø—Ä–∞–≤–æ–π —á–∞—Å—Ç–∏ –≤ –ª–µ–≤—É—é
        directionY: 1,  // –î–≤–∏–∂–µ–Ω–∏–µ –∏–∑ –≤–µ—Ä—Ö–Ω–µ–π —á–∞—Å—Ç–∏ –≤ –Ω–∏–∂–Ω—é—é
        layers: {
          stars: 0.3,    // –°–∞–º—ã–π –º–µ–¥–ª–µ–Ω–Ω—ã–π —Å–ª–æ–π
          nebulae: 0.5,  // –°—Ä–µ–¥–Ω—è—è —Å–∫–æ—Ä–æ—Å—Ç—å
          particles: 0.8, // –ë—ã—Å—Ç—Ä—ã–π —Å–ª–æ–π
          special: 1.0   // –°–∞–º—ã–π –±—ã—Å—Ç—Ä—ã–π —Å–ª–æ–π
        }
      };
      // –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ï –ù–ê–°–¢–†–û–ô–ö–ò
      const fixedSettings = {
        speed: 5,
        density: 5,
        size: 5,
        smoothness: 5,
        nebulaIntensity: 3,
        starDensity: 2
      };
      // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏
      let animationId = null;
      let currentPlanet = 'mercury';
      let time = 0;
      // –ú–∞—Å—Å–∏–≤—ã –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∞–Ω–∏–º–∞—Ü–∏–∏
      let particles = [];
      let specialElements = [];
      let nebulae = [];
      let stars = [];
      // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø–ª–∞–Ω–µ—Ç
      const planetData = {
        mercury: {
          name: '–ú–µ—Ä–∫—É—Ä–∏–π',
          colors: ['#8c7b6b', '#a69b8f', '#5a524c', '#ffaa33', '#ffcc66', '#d9b382', '#bf9e75'],
          background: ['#1a0f0a', '#2c1d14', '#4a3527'],
          type: 'rocky'
        },
        venus: {
          name: '–í–µ–Ω–µ—Ä–∞',
          colors: ['#e6b87e', '#d4a574', '#ff8844', '#b35900', '#ff9966', '#e68a53', '#cc7a3d'],
          background: ['#2a1a0f', '#4a2c1a', '#6b3f20'],
          type: 'cloudy'
        },
        earth: {
          name: '–ó–µ–º–ª—è',
          colors: ['#4a7b9d', '#5d8aa8', '#2e5a78', '#87ceeb', '#a8d5e5', '#6baed6', '#3c8dbc'],
          background: ['#0a1a2a', '#1a2a3a', '#2a3a4a'],
          type: 'oceanic'
        },
        mars: {
          name: '–ú–∞—Ä—Å',
          colors: ['#cd5c5c', '#a52a2a', '#8b4513', '#ff6347', '#e2583e', '#c14533', '#a33226'],
          background: ['#2a0f0a', '#4a1a14', '#6b251e'],
          type: 'dusty'
        },
        jupiter: {
          name: '–Æ–ø–∏—Ç–µ—Ä',
          colors: ['#d2b48c', '#bc8f8f', '#a0522d', '#ff7f50', '#e67347', '#cc663d', '#b35933'],
          background: ['#2a1f14', '#4a3728', '#6b4f3c'],
          type: 'stormy'
        },
        saturn: {
          name: '–°–∞—Ç—É—Ä–Ω',
          colors: ['#f0e68c', '#daa520', '#b8860b', '#ffd700', '#e6c347', '#ccaa3d', '#b39233'],
          background: ['#2a2414', '#4a3c28', '#6b543c'],
          type: 'ringed'
        },
        uranus: {
          name: '–£—Ä–∞–Ω',
          colors: ['#afeeee', '#7fffd4', '#40e0d0', '#48d1cc', '#3dc4bf', '#32b7b2', '#27aaa5'],
          background: ['#0a1a2a', '#1a2a3a', '#2a3a4a'],
          type: 'icy'
        },
        neptune: {
          name: '–ù–µ–ø—Ç—É–Ω',
          colors: ['#4169e1', '#0000cd', '#191970', '#1e90ff', '#1a7feb', '#166fd7', '#125fc3'],
          background: ['#0a0a2a', '#1a1a3a', '#2a2a4a'],
          type: 'windy'
        },
        pluto: {
          name: '–ü–ª—É—Ç–æ–Ω',
          colors: ['#a9a9a9', '#696969', '#808080', '#d3d3d3', '#c0c0c0', '#b0b0b0', '#9e9e9e'],
          background: ['#1a1a2a', '#2a2a3a', '#3a3a4a'],
          type: 'dwarf'
        }
      };
      // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ä–∞–∑–º–µ—Ä–æ–≤ canvas
      function setCanvasSize() {
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
        if (isMobile) {
          const pixelRatio = window.devicePixelRatio || 1;
          canvas.width = canvas.offsetWidth * pixelRatio;
          canvas.height = canvas.offsetHeight * pixelRatio;
          ctx.scale(pixelRatio, pixelRatio);
        }
      }
      // –ö–ª–∞—Å—Å —á–∞—Å—Ç–∏—Ü —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –ø–∞—Ä–∞–ª–ª–∞–∫—Å–∞
      class Particle {
        constructor(x, y, radius, color, velocity, type, parallaxFactor = 1) {
          this.x = x;
          this.y = y;
          this.radius = radius;
          this.color = color;
          this.velocity = velocity;
          this.alpha = 1;
          this.type = type;
          this.rotation = Math.random() * Math.PI * 2;
          this.rotationSpeed = (Math.random() - 0.5) * 0.02;
          this.pulse = Math.random() * Math.PI * 2;
          this.twinkle = Math.random() * Math.PI * 2;
          this.twinkleSpeed = 0.05 + Math.random() * 0.05;
          this.lifetime = 1;
          this.maxLifetime = 1;
          this.parallaxFactor = parallaxFactor;
        }
        draw() {
          ctx.save();
          if (this.type === 'star') {
            const twinkleFactor = 0.7 + 0.3 * Math.sin(this.twinkle);
            ctx.globalAlpha = this.alpha * twinkleFactor * this.lifetime;
          } else if (this.type === 'ice') {
            ctx.globalAlpha = this.alpha * this.lifetime;
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
              const angle = (i * Math.PI) / 3;
              const x = Math.cos(angle) * this.radius;
              const y = Math.sin(angle) * this.radius;
              if (i === 0) {
                ctx.moveTo(x, y);
              } else {
                ctx.lineTo(x, y);
              }
            }
            ctx.closePath();
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.restore();
            return;
          } else {
            ctx.globalAlpha = this.alpha * this.lifetime;
          }
          ctx.translate(this.x, this.y);
          if (this.type === 'ring') {
            ctx.rotate(this.rotation);
            ctx.beginPath();
            ctx.ellipse(0, 0, this.radius, this.radius/3, 0, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
          } else if (this.type === 'nebula') {
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
            gradient.addColorStop(0, this.color + 'aa');
            gradient.addColorStop(1, this.color + '00');
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
          } else if (this.type === 'crystal') {
            ctx.rotate(this.rotation);
            ctx.beginPath();
            ctx.moveTo(0, -this.radius);
            ctx.lineTo(this.radius/2, 0);
            ctx.lineTo(0, this.radius);
            ctx.lineTo(-this.radius/2, 0);
            ctx.closePath();
            ctx.fillStyle = this.color;
            ctx.fill();
          } else {
            const pulseFactor = 0.8 + 0.2 * Math.sin(this.pulse);
            ctx.beginPath();
            ctx.arc(0, 0, this.radius * pulseFactor, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
          }
          ctx.restore();
        }
        update() {
          this.draw();
          // –î–≤–∏–∂–µ–Ω–∏–µ –ø–∞—Ä–∞–ª–ª–∞–∫—Å–∞
          const parallaxSpeed = parallaxSettings.baseSpeed * this.parallaxFactor;
          this.x += parallaxSettings.directionX * parallaxSpeed;
          this.y += parallaxSettings.directionY * parallaxSpeed;
          // –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ —á–∞—Å—Ç–∏—Ü—ã
          const smoothFactor = fixedSettings.smoothness / 10;
          this.velocity.x *= (1 - smoothFactor * 0.05);
          this.velocity.y *= (1 - smoothFactor * 0.05);
          this.x += this.velocity.x;
          this.y += this.velocity.y;
          this.rotation += this.rotationSpeed;
          this.pulse += 0.05;
          this.twinkle += this.twinkleSpeed;
          // Teleport-–∞—Ü–∏—è –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã
          if (this.x < -this.radius * 2) {
            this.x = canvas.width + this.radius;
          } else if (this.x > canvas.width + this.radius * 2) {
            this.x = -this.radius;
          }
          if (this.y < -this.radius * 2) {
            this.y = canvas.height + this.radius;
          } else if (this.y > canvas.height + this.radius * 2) {
            this.y = -this.radius;
          }
        }
      }
      // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω–æ–≥–æ —Ñ–æ–Ω–∞
      function drawBackground() {
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        const bgColors = planetData[currentPlanet].background;
        gradient.addColorStop(0, bgColors[0]);
        gradient.addColorStop(0.5, bgColors[1]);
        gradient.addColorStop(1, bgColors[2]);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–≤–µ–∑–¥ —Å –ø–∞—Ä–∞–ª–ª–∞–∫—Å–æ–º
      function generateStars() {
        const starCount = fixedSettings.starDensity * 50;
        stars = [];
        for (let i = 0; i < starCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * 1.5 + 0.5;
          const starColors = ['#ffffff', '#f8f8ff', '#e6e6fa', '#fffacd', '#f0f8ff'];
          const color = starColors[Math.floor(Math.random() * starColors.length)];
          const velocity = {
            x: 0,
            y: 0
          };
          stars.push(new Particle(x, y, radius, color, velocity, 'star', parallaxSettings.layers.stars));
        }
      }
      // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç—É–º–∞–Ω–Ω–æ—Å—Ç–µ–π —Å –ø–∞—Ä–∞–ª–ª–∞–∫—Å–æ–º
      function generateNebulae() {
        const nebulaCount = fixedSettings.nebulaIntensity;
        nebulae = [];
        for (let i = 0; i < nebulaCount; i++) {
          const aspectRatio = canvas.width / canvas.height;
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * 200 + (aspectRatio > 1 ? 80 : 120);
          const planetColors = planetData[currentPlanet].colors;
          const color = planetColors[Math.floor(Math.random() * planetColors.length)];
          const velocity = {
            x: (Math.random() - 0.5) * 0.05,
            y: (Math.random() - 0.5) * 0.05
          };
          nebulae.push(new Particle(x, y, radius, color, velocity, 'nebula', parallaxSettings.layers.nebulae));
        }
      }
      // –û–ë–ù–û–í–õ–ï–ù–ù–´–ï –§–£–ù–ö–¶–ò–ò –ì–ï–ù–ï–†–ê–¶–ò–ò –° –ü–ê–†–ê–õ–õ–ê–ö–°–û–ú
      function generateMercury() {
        const particleCount = fixedSettings.density * 15;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size * 2 + 1;
          const color = planetData.mercury.colors[Math.floor(Math.random() * planetData.mercury.colors.length)];
          const speedValue = (Math.random() * 0.5 + 0.1) * fixedSettings.speed / 5;
          const angle = Math.random() * Math.PI * 2;
          const velocity = {
            x: Math.cos(angle) * speedValue,
            y: Math.sin(angle) * speedValue
          };
          particles.push(new Particle(x, y, radius, color, velocity, 'rock', parallaxSettings.layers.particles));
        }
        for (let i = 0; i < 5; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * 20 + 10;
          const color = planetData.mercury.colors[3];
          const velocity = {
            x: 0,
            y: 0
          };
          specialElements.push(new Particle(x, y, radius, color, velocity, 'sun', parallaxSettings.layers.special));
        }
      }
      function generateVenus() {
        const particleCount = fixedSettings.density * 20;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size * 3 + 5;
          const color = planetData.venus.colors[Math.floor(Math.random() * planetData.venus.colors.length)];
          const speedValue = (Math.random() * 0.3 + 0.1) * fixedSettings.speed / 5;
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          const dx = x - centerX;
          const dy = y - centerY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx) + Math.PI / 2;
          const velocity = {
            x: Math.cos(angle) * speedValue * (distance / 100),
            y: Math.sin(angle) * speedValue * (distance / 100)
          };
          particles.push(new Particle(x, y, radius, color, velocity, 'cloud', parallaxSettings.layers.particles));
        }
      }
      function generateEarth() {
        const particleCount = fixedSettings.density * 25;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size * 2 + 2;
          const color = planetData.earth.colors[Math.floor(Math.random() * planetData.earth.colors.length)];
          const speedValue = (Math.random() * 0.5 + 0.2) * fixedSettings.speed / 5;
          const angle = Math.random() > 0.5 ? 
            Math.PI / 2 + (Math.random() - 0.5) * 0.5 : 
            -Math.PI / 2 + (Math.random() - 0.5) * 0.5;
          const velocity = {
            x: Math.cos(angle) * speedValue,
            y: Math.sin(angle) * speedValue
          };
          particles.push(new Particle(x, y, radius, color, velocity, 'water', parallaxSettings.layers.particles));
        }
      }
      function generateMars() {
        const particleCount = fixedSettings.density * 30;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size + 1;
          const color = planetData.mars.colors[Math.floor(Math.random() * planetData.mars.colors.length)];
          const speedValue = (Math.random() * 1 + 0.5) * fixedSettings.speed / 5;
          const angle = Math.random() * Math.PI * 2;
          const velocity = {
            x: Math.cos(angle) * speedValue,
            y: Math.sin(angle) * speedValue
          };
          particles.push(new Particle(x, y, radius, color, velocity, 'dust', parallaxSettings.layers.particles));
        }
      }
      function generateJupiter() {
        const particleCount = fixedSettings.density * 15;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size * 4 + 10;
          const color = planetData.jupiter.colors[Math.floor(Math.random() * planetData.jupiter.colors.length)];
          const speedValue = (Math.random() * 0.2 + 0.1) * fixedSettings.speed / 5;
          const direction = Math.random() > 0.5 ? 1 : -1;
          const velocity = {
            x: speedValue * direction,
            y: 0
          };
          particles.push(new Particle(x, y, radius, color, velocity, 'storm', parallaxSettings.layers.particles));
        }
        const x = canvas.width * 0.7;
        const y = canvas.height * 0.5;
        const radius = 50;
        const color = planetData.jupiter.colors[3];
        const velocity = {
          x: -0.1 * fixedSettings.speed / 5,
          y: 0
        };
        specialElements.push(new Particle(x, y, radius, color, velocity, 'spot', parallaxSettings.layers.special));
      }
      function generateSaturn() {
        const particleCount = fixedSettings.density * 10;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = 100 + Math.random() * 150;
          const x = canvas.width / 2 + Math.cos(angle) * distance;
          const y = canvas.height / 2 + Math.sin(angle) * distance;
          const radius = Math.random() * fixedSettings.size * 2 + 5;
          const color = planetData.saturn.colors[Math.floor(Math.random() * planetData.saturn.colors.length)];
          const speedValue = (Math.random() * 0.3 + 0.1) * fixedSettings.speed / 5;
          const orbitalAngle = angle + Math.PI / 2;
          const velocity = {
            x: Math.cos(orbitalAngle) * speedValue,
            y: Math.sin(orbitalAngle) * speedValue
          };
          particles.push(new Particle(x, y, radius, color, velocity, 'ring', parallaxSettings.layers.particles));
        }
        for (let i = 0; i < fixedSettings.density * 5; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size * 3 + 5;
          const color = planetData.saturn.colors[Math.floor(Math.random() * planetData.saturn.colors.length)];
          const speedValue = (Math.random() * 0.2 + 0.1) * fixedSettings.speed / 5;
          const angle = Math.random() * Math.PI * 2;
          const velocity = {
            x: Math.cos(angle) * speedValue,
            y: Math.sin(angle) * speedValue
          };
          particles.push(new Particle(x, y, radius, color, velocity, 'cloud', parallaxSettings.layers.particles));
        }
      }
      function generateUranus() {
        const particleCount = fixedSettings.density * 20;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size * 2 + 3;
          const color = planetData.uranus.colors[Math.floor(Math.random() * planetData.uranus.colors.length)];
          const speedValue = (Math.random() * 0.2 + 0.05) * fixedSettings.speed / 5;
          const angle = Math.random() * Math.PI * 2;
          const velocity = {
            x: Math.cos(angle) * speedValue,
            y: Math.sin(angle) * speedValue
          };
          particles.push(new Particle(x, y, radius, color, velocity, 'ice', parallaxSettings.layers.particles));
        }
      }
      function generateNeptune() {
        const particleCount = fixedSettings.density * 25;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size + 2;
          const color = planetData.neptune.colors[Math.floor(Math.random() * planetData.neptune.colors.length)];
          const speedValue = (Math.random() * 0.8 + 0.3) * fixedSettings.speed / 5;
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          const dx = x - centerX;
          const dy = y - centerY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx) + Math.PI / 2;
          const velocity = {
            x: Math.cos(angle) * speedValue * (1 + distance / 200),
            y: Math.sin(angle) * speedValue * (1 + distance / 200)
          };
          particles.push(new Particle(x, y, radius, color, velocity, 'wind', parallaxSettings.layers.particles));
        }
        for (let i = 0; i < 3; i++) {
          const x = canvas.width * (0.2 + i * 0.3);
          const y = canvas.height * 0.5;
          const radius = 30 + Math.random() * 20;
          const color = planetData.neptune.colors[2];
          const velocity = {
            x: 0.2 * fixedSettings.speed / 5,
            y: 0
          };
          specialElements.push(new Particle(x, y, radius, color, velocity, 'spot', parallaxSettings.layers.special));
        }
      }
      function generatePluto() {
        const particleCount = fixedSettings.density * 20;
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * fixedSettings.size * 1.5 + 2;
          const color = planetData.pluto.colors[Math.floor(Math.random() * planetData.pluto.colors.length)];
          const speedValue = (Math.random() * 0.3 + 0.1) * fixedSettings.speed / 5;
          const angle = Math.random() * Math.PI * 2;
          const velocity = {
            x: Math.cos(angle) * speedValue,
            y: Math.sin(angle) * speedValue
          };
          if (i % 3 === 0) {
            particles.push(new Particle(x, y, radius, color, velocity, 'ice', parallaxSettings.layers.particles));
          } else if (i % 3 === 1) {
            particles.push(new Particle(x, y, radius, color, velocity, 'crystal', parallaxSettings.layers.particles));
          } else {
            particles.push(new Particle(x, y, radius, color, velocity, 'rock', parallaxSettings.layers.particles));
          }
        }
        for (let i = 0; i < 3; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const radius = Math.random() * 30 + 20;
          const color = planetData.pluto.colors[3];
          const velocity = {
            x: (Math.random() - 0.5) * 0.1,
            y: (Math.random() - 0.5) * 0.1
          };
          specialElements.push(new Particle(x, y, radius, color, velocity, 'ice', parallaxSettings.layers.special));
        }
      }
      // –ê–Ω–∏–º–∞—Ü–∏—è —á–∞—Å—Ç–∏—Ü
      function animateParticles() {
        drawBackground();
        nebulae.forEach(nebula => {
          nebula.update();
        });
        stars.forEach(star => {
          star.update();
        });
        particles.forEach(particle => {
          particle.update();
        });
        specialElements.forEach(element => {
          element.update();
        });
      }
      // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∞–Ω–∏–º–∞—Ü–∏–∏
      function animate() {
        time += 0.01;
        animateParticles();
        animationId = requestAnimationFrame(animate);
      }
      // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ñ–æ–Ω–∞ –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π –ø–ª–∞–Ω–µ—Ç—ã
      function generatePlanetBackground() {
        if (animationId) {
          cancelAnimationFrame(animationId);
        }
        particles = [];
        specialElements = [];
        nebulae = [];
        stars = [];
        generateStars();
        generateNebulae();
        const genMap = {
          mercury: generateMercury,
          venus: generateVenus,
          earth: generateEarth,
          mars: generateMars,
          jupiter: generateJupiter,
          saturn: generateSaturn,
          uranus: generateUranus,
          neptune: generateNeptune,
          pluto: generatePluto
        };
        genMap[currentPlanet]();
        animate();
      }
      // –°–º–µ–Ω–∞ –ø–ª–∞–Ω–µ—Ç—ã
      function changePlanet(planet) {
        currentPlanet = planet;
        generatePlanetBackground();
      }
      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
      function init() {
        setCanvasSize();
        generatePlanetBackground();
        window.addEventListener('resize', setCanvasSize);
      }
      // –ü—É–±–ª–∏—á–Ω—ã–µ –º–µ—Ç–æ–¥—ã
      window.planetBackground = {
        init: init,
        setPlanet: changePlanet,
        setCanvasSize: setCanvasSize
      };
    })();
    // === –ö–û–î –ò–ì–†–´ ===
    document.addEventListener('DOMContentLoaded', function() {
        // –ü–µ—Ä–µ–≤–æ–¥—ã –¥–ª—è —Ç—Ä–µ—Ö —è–∑—ã–∫–æ–≤
        const translations = {
            ru: {
                // UI —ç–ª–µ–º–µ–Ω—Ç—ã
                gameTitle: {
                    mercury: "‚òø –ú–µ—Ä–∫—É—Ä–∏–π",
                    venus: "‚ôÄ –í–µ–Ω–µ—Ä–∞",
                    earth: "‚ôÅ –ó–µ–º–ª—è",
                    mars: "‚ôÇ –ú–∞—Ä—Å",
                    jupiter: "‚ôÉ –Æ–ø–∏—Ç–µ—Ä",
                    saturn: "‚ôÑ –°–∞—Ç—É—Ä–Ω",
                    uranus: "‚ôÖ –£—Ä–∞–Ω",
                    neptune: "‚ôÜ –ù–µ–ø—Ç—É–Ω",
                    pluto: "‚ôá –ü–ª—É—Ç–æ–Ω"
                },
                hud: {
                    coins: "–ö—Ä–∏—Å—Ç–∞–ª–ª—ã: ",
                    clickPower: "–°–∏–ª–∞: ",
                    critChance: "–ö—Ä–∏—Ç: ",
                    critMultiplier: "–ú–Ω–æ–∂: "
                },
                progressText: "–ü—Ä–æ–≥—Ä–µ—Å—Å: {current} / {target} –∞.–µ. ({percent}%)",
                // –ö–Ω–æ–ø–∫–∏
                buttons: {
                    save: "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–≥—Ä—É",
                    continue: "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å",
                    noSave: "–ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è",
                    start: "–ù–æ–≤–∞—è –∏–≥—Ä–∞",
                    loadSave: "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—É—é –∏–≥—Ä—É",
                    newGame: "–ù–∞—á–∞—Ç—å –Ω–æ–≤—É—é –∏–≥—Ä—É",
                    cancel: "–û—Ç–º–µ–Ω–∞",
                    restart: "–ù–æ–≤–∞—è –¥–æ–±—ã—á–∞",
                    share: "–ü–æ–¥–µ–ª–∏—Ç—å—Å—è",
                    lang: "–°–º–µ–Ω–∏—Ç—å —è–∑—ã–∫"
                },
                // –≠–∫—Ä–∞–Ω—ã
                welcome: {
                    title: "üöÄ –ö–û–°–ú–ò–ß–ï–°–ö–ò–ô –ö–õ–ò–ö–ï–†",
                    text1: "–†–∞–∑—Ä—É—à–∞–π—Ç–µ –≤–æ—Å—Ö–æ–¥—è—â–∏–µ –±–ª–æ–∫–∏ –∏ —Å–æ–±–∏—Ä–∞–π—Ç–µ <strong>–∫–æ—Å–º–∏—á–µ—Å–∫–∏–µ –ö—Ä–∏—Å—Ç–∞–ª–ª—ã</strong>!",
                    text2: "–ö–∞–∂–¥—ã–π –±–ª–æ–∫ —Ç—Ä–µ–±—É–µ—Ç –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —É–¥–∞—Ä–æ–≤ –¥–ª—è —Ä–∞–∑—Ä—É—à–µ–Ω–∏—è.",
                    text3: "<strong>–†–µ–∞–ª–∏—Å—Ç–∏—á–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞:</strong>",
                    text4: "üåå <strong>–ê—Å—Ç—Ä–æ–Ω–æ–º–∏—á–µ—Å–∫–∏–µ –µ–¥–∏–Ω–∏—Ü—ã</strong> ‚Äî –ø–µ—Ä–µ–º–µ—â–∞–π—Ç–µ—Å—å –ø–æ –°–æ–ª–Ω–µ—á–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ",
                    text5: "ü™ê <strong>9 —Ä–µ–∞–ª—å–Ω—ã—Ö –ø–ª–∞–Ω–µ—Ç</strong> ‚Äî –æ—Ç –ú–µ—Ä–∫—É—Ä–∏—è –¥–æ –ü–ª—É—Ç–æ–Ω–∞",
                    text6: "üöÄ <strong>–£–ª—É—á—à–µ–Ω–∏—è</strong> ‚Äî —É–≤–µ–ª–∏—á–∏–≤–∞–π—Ç–µ —Å–∏–ª—É, –∫—Ä–∏—Ç—ã –∏ –∞–∫—Ç–∏–≤–∏—Ä—É–π—Ç–µ –ø–æ–º–æ—â–Ω–∏–∫–∞",
                    text7: "‚ú® <strong>–†–µ–¥–∫–∏–µ –±–ª–æ–∫–∏</strong> ‚Äî –¥–∞—é—Ç –±–æ–Ω—É—Å—ã –∏ –æ–≥—Ä–æ–º–Ω—ã–µ –Ω–∞–≥—Ä–∞–¥—ã!"
                },
                saveScreen: {
                    title: "–°–û–•–†–ê–ù–ï–ù–ò–ï –ò–ì–†–´",
                    text: "–•–æ—Ç–∏—Ç–µ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–π –∏–≥—Ä—ã –∏–ª–∏ –Ω–∞—á–∞—Ç—å –Ω–æ–≤—É—é?"
                },
                gameOver: {
                    title: "–î–û–ë–´–ß–ê –ü–†–ï–†–í–ê–ù–ê!",
                    score: "–í—Å–µ–≥–æ —É—Ä–æ–Ω–∞: {damage}",
                    newGame: "–ù–æ–≤–∞—è –∏–≥—Ä–∞"
                },
                tooltips: {
                    saveSuccess: "–ò–≥—Ä–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!",
                    upgradeClick: "–°–∏–ª–∞ —É–¥–∞—Ä–∞<br>–ù–µ–ª–∏–Ω–µ–π–Ω—ã–π —Ä–æ—Å—Ç —É—Ä–æ–Ω–∞",
                    upgradeHelper: "Bobo<br>–ê–≤—Ç–æ-–∞—Ç–∞–∫–∞ –Ω–∞ 1 –º–∏–Ω—É—Ç—É<br>+30% —É—Ä–æ–Ω–∞<br>+20% –∫ –∫—Ä–∏—Å—Ç–∞–ª–ª–∞–º",
                    upgradeCritChance: "–®–∞–Ω—Å –∫—Ä–∏—Ç–∞<br>+0.1% —à–∞–Ω—Å –∫—Ä–∏—Ç. —É—Ä–æ–Ω–∞",
                    upgradeCritMult: "–ú–Ω–æ–∂–∏—Ç–µ–ª—å –∫—Ä–∏—Ç–∞<br>+0.2x –∫—Ä–∏—Ç. —É—Ä–æ–Ω–∞",
                    upgradeHelperDmg: "–£—Ä–æ–Ω Bobo<br>+20% —É—Ä–æ–Ω–∞ –∑–∞ –∞–ø–≥—Ä–µ–π–¥",
                    combo: "–ö–æ–º–±–æ x{count}! +{bonus}",
                    reward: "+{reward} üíé",
                    helperAvailable: "Bobo –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –Ω–∞ 1 –º–∏–Ω—É—Ç—É!<br>–ë–æ–Ω—É—Å –∫ –∫—Ä–∏—Å—Ç–∞–ª–ª–∞–º: +20%",
                    helperEnd: "Bobo –∑–∞–∫–æ–Ω—á–∏–ª —Ä–∞–±–æ—Ç—É!",
                    critChanceUpgrade: "–®–∞–Ω—Å –∫—Ä–∏—Ç–∞ +0.1%!<br>–¢–µ–ø–µ—Ä—å: {chance}%",
                    critMultUpgrade: "–ú–Ω–æ–∂–∏—Ç–µ–ª—å –∫—Ä–∏—Ç–∞ +0.2x!<br>–¢–µ–ø–µ—Ä—å: x{mult}",
                    helperDmgUpgrade: "–£—Ä–æ–Ω Bobo +20%!<br>–£—Ä–æ–≤–µ–Ω—å: {level}",
                    clickPowerUpgrade: "–°–∏–ª–∞ —É–≤–µ–ª–∏—á–µ–Ω–∞!<br>–¢–µ–ø–µ—Ä—å: {power}",
                    noSave: "–ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–π –∏–≥—Ä—ã!",
                    shareSuccess: "+50 –ö—Ä–∏—Å—Ç–∞–ª–ª–æ–≤ –∑–∞ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ!"
                },
                rareBlocks: {
                    gold: "–ó–æ–ª–æ—Ç–æ–π",
                    rainbow: "–†–∞–¥—É–∂–Ω—ã–π",
                    crystal: "–ö—Ä–∏—Å—Ç–∞–ª—å–Ω—ã–π",
                    mystery: "–ó–∞–≥–∞–¥–æ—á–Ω—ã–π"
                },
                locationProgress: {
                    unlocked: "–û—Ç–∫—Ä—ã—Ç–∞ –ª–æ–∫–∞—Ü–∏—è: {location}!"
                }
            },
            en: {
                // UI elements
                gameTitle: {
                    mercury: "‚òø Mercury",
                    venus: "‚ôÄ Venus",
                    earth: "‚ôÅ Earth",
                    mars: "‚ôÇ Mars",
                    jupiter: "‚ôÉ Jupiter",
                    saturn: "‚ôÑ Saturn",
                    uranus: "‚ôÖ Uranus",
                    neptune: "‚ôÜ Neptune",
                    pluto: "‚ôá Pluto"
                },
                hud: {
                    coins: "Crystals: ",
                    clickPower: "Power: ",
                    critChance: "Crit: ",
                    critMultiplier: "Mult: "
                },
                progressText: "Progress: {current} / {target} a.u. ({percent}%)",
                // Buttons
                buttons: {
                    save: "Save game",
                    continue: "Continue",
                    noSave: "No save",
                    start: "New game",
                    loadSave: "Continue saved game",
                    newGame: "Start new game",
                    cancel: "Cancel",
                    restart: "New game",
                    share: "Share",
                    lang: "Change language"
                },
                // Screens
                welcome: {
                    title: "üöÄ SPACE CLICKER",
                    text1: "Destroy rising blocks and collect <strong>cosmic Crystals</strong>!",
                    text2: "Each block requires a specific number of hits to destroy.",
                    text3: "<strong>Realistic progress system:</strong>",
                    text4: "üåå <strong>Astronomical units</strong> - travel through the Solar System",
                    text5: "ü™ê <strong>9 real planets</strong> - from Mercury to Pluto",
                    text6: "üöÄ <strong>Upgrades</strong> - increase power, crits and activate assistant",
                    text7: "‚ú® <strong>Rare blocks</strong> - provide bonuses and huge rewards!"
                },
                saveScreen: {
                    title: "GAME SAVE",
                    text: "Do you want to continue with the saved game or start a new one?"
                },
                gameOver: {
                    title: "MINING INTERRUPTED!",
                    score: "Total damage: {damage}",
                    newGame: "New Game"
                },
                tooltips: {
                    saveSuccess: "Game saved!",
                    upgradeClick: "Click power<br>Non-linear damage growth",
                    upgradeHelper: "Bobo<br>Auto-attack for 1 minute<br>+30% damage<br>+20% to crystals",
                    upgradeCritChance: "Crit chance<br>+0.1% crit hit chance",
                    upgradeCritMult: "Crit multiplier<br>+0.2x crit damage",
                    upgradeHelperDmg: "Bobo damage<br>+20% damage per upgrade",
                    combo: "Combo x{count}! +{bonus}",
                    reward: "+{reward} üíé",
                    helperAvailable: "Bobo activated for 1 minute!<br>Crystals bonus: +20%",
                    helperEnd: "Bobo has finished working!",
                    critChanceUpgrade: "Crit chance +0.1%!<br>Now: {chance}%",
                    critMultUpgrade: "Crit multiplier +0.2x!<br>Now: x{mult}",
                    helperDmgUpgrade: "Bobo damage +20%!<br>Level: {level}",
                    clickPowerUpgrade: "Power increased!<br>Now: {power}",
                    noSave: "No saved game!",
                    shareSuccess: "+50 Crystals for sharing!"
                },
                rareBlocks: {
                    gold: "Gold",
                    rainbow: "Rainbow",
                    crystal: "Crystal",
                    mystery: "Mystery"
                },
                locationProgress: {
                    unlocked: "Unlocked location: {location}!"
                }
            },
            zh: {
                // UI elements
                gameTitle: {
                    mercury: "‚òø Ê∞¥Êòü",
                    venus: "‚ôÄ ÈáëÊòü",
                    earth: "‚ôÅ Âú∞ÁêÉ",
                    mars: "‚ôÇ ÁÅ´Êòü",
                    jupiter: "‚ôÉ Êú®Êòü",
                    saturn: "‚ôÑ ÂúüÊòü",
                    uranus: "‚ôÖ Â§©ÁéãÊòü",
                    neptune: "‚ôÜ Êµ∑ÁéãÊòü",
                    pluto: "‚ôá ÂÜ•ÁéãÊòü"
                },
                hud: {
                    coins: "Ê∞¥Êô∂: ",
                    clickPower: "ÂäõÈáè: ",
                    critChance: "Êö¥Âáª: ",
                    critMultiplier: "ÂÄçÊï∞: "
                },
                progressText: "ËøõÂ∫¶: {current} / {target} Â§©ÊñáÂçï‰Ωç ({percent}%)",
                // Buttons
                buttons: {
                    save: "‰øùÂ≠òÊ∏∏Êàè",
                    continue: "ÁªßÁª≠",
                    noSave: "Ê≤°Êúâ‰øùÂ≠ò",
                    start: "Êñ∞Ê∏∏Êàè",
                    loadSave: "ÁªßÁª≠‰øùÂ≠òÁöÑÊ∏∏Êàè",
                    newGame: "ÂºÄÂßãÊñ∞Ê∏∏Êàè",
                    cancel: "ÂèñÊ∂à",
                    restart: "Êñ∞Ê∏∏Êàè",
                    share: "ÂàÜ‰∫´",
                    lang: "Êõ¥ÊîπËØ≠Ë®Ä"
                },
                // Screens
                welcome: {
                    title: "üöÄ Â§™Á©∫ÁÇπÂáªÂô®",
                    text1: "ÊëßÊØÅ‰∏äÂçáÁöÑÊñπÂùóÂπ∂Êî∂ÈõÜ<strong>ÂÆáÂÆôÊ∞¥Êô∂</strong>!",
                    text2: "ÊØè‰∏™ÊñπÂùóÈúÄË¶ÅÁâπÂÆöÊ¨°Êï∞ÁöÑÁÇπÂáªÊâçËÉΩÊëßÊØÅ„ÄÇ",
                    text3: "<strong>ÁúüÂÆûÁöÑËøõÂ∫¶Á≥ªÁªü:</strong>",
                    text4: "üåå <strong>Â§©ÊñáÂçï‰Ωç</strong> - Âú®Â§™Èò≥Á≥ª‰∏≠ÊóÖË°å",
                    text5: "ü™ê <strong>9È¢óÁúüÂÆûË°åÊòü</strong> - ‰ªéÊ∞¥ÊòüÂà∞ÂÜ•ÁéãÊòü",
                    text6: "üöÄ <strong>ÂçáÁ∫ß</strong> - Â¢ûÂä†ÂäõÈáè, Êö¥ÂáªÂíåÊøÄÊ¥ªÂä©Êâã",
                    text7: "‚ú® <strong>Á®ÄÊúâÊñπÂùó</strong> - Êèê‰æõÂ•ñÂä±ÂíåÂ∑®Â§ßÂ•ñÂä±!"
                },
                saveScreen: {
                    title: "Ê∏∏Êàè‰øùÂ≠ò",
                    text: "ÊÇ®ÊÉ≥ÁªßÁª≠‰øùÂ≠òÁöÑÊ∏∏ÊàèËøòÊòØÂºÄÂßãÊñ∞Ê∏∏ÊàèÔºü"
                },
                gameOver: {
                    title: "ÂºÄÈáá‰∏≠Êñ≠!",
                    score: "ÊÄª‰º§ÂÆ≥: {damage}",
                    newGame: "Êñ∞Ê∏∏Êàè"
                },
                tooltips: {
                    saveSuccess: "Ê∏∏ÊàèÂ∑≤‰øùÂ≠ò!",
                    upgradeClick: "ÁÇπÂáªÂäõÈáè<br>ÈùûÁ∫øÊÄß‰º§ÂÆ≥Â¢ûÈïø",
                    upgradeHelper: "Bobo<br>Ëá™Âä®ÊîªÂáª1ÂàÜÈíü<br>+30%‰º§ÂÆ≥<br>+20%Ê∞¥Êô∂",
                    upgradeCritChance: "Êö¥ÂáªÂá†Áéá<br>+0.1%Êö¥ÂáªÂëΩ‰∏≠Âá†Áéá",
                    upgradeCritMult: "Êö¥ÂáªÂÄçÊï∞<br>+0.2xÊö¥Âáª‰º§ÂÆ≥",
                    upgradeHelperDmg: "Bobo‰º§ÂÆ≥<br>+20%ÊØèÊ¨°ÂçáÁ∫ß‰º§ÂÆ≥",
                    combo: "ËøûÂáª x{count}! +{bonus}",
                    reward: "+{reward} üíé",
                    helperAvailable: "BoboÂ∑≤ÊøÄÊ¥ª1ÂàÜÈíü!<br>Ê∞¥Êô∂Â•ñÂä±: +20%",
                    helperEnd: "BoboÂ∑≤ÂÆåÊàêÂ∑•‰Ωú!",
                    critChanceUpgrade: "Êö¥ÂáªÂá†Áéá +0.1%!<br>Áé∞Âú®: {chance}%",
                    critMultUpgrade: "Êö¥ÂáªÂÄçÊï∞ +0.2x!<br>Áé∞Âú®: x{mult}",
                    helperDmgUpgrade: "Bobo‰º§ÂÆ≥ +20%!<br>Á≠âÁ∫ß: {level}",
                    clickPowerUpgrade: "ÂäõÈáèÂ¢ûÂä†!<br>Áé∞Âú®: {power}",
                    noSave: "Ê≤°Êúâ‰øùÂ≠òÁöÑÊ∏∏Êàè!",
                    shareSuccess: "ÂàÜ‰∫´Ëé∑Âæó+50Ê∞¥Êô∂!"
                },
                rareBlocks: {
                    gold: "ÈáëËâ≤",
                    rainbow: "ÂΩ©Ëôπ",
                    crystal: "Ê∞¥Êô∂",
                    mystery: "Á•ûÁßò"
                },
                locationProgress: {
                    unlocked: "Ëß£ÈîÅ‰ΩçÁΩÆ: {location}!"
                }
            }
        };
        
        // –¢–µ–∫—É—â–∏–π —è–∑—ã–∫
        let currentLanguage = localStorage.getItem('gameLanguage') || 'ru';
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Ç—Ä–æ–∫ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
        function formatString(template, params) {
            return template.replace(/{(\w+)}/g, (match, key) => {
                return params.hasOwnProperty(key) ? params[key] : match;
            });
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –ø–µ—Ä–µ–≤–æ–¥–∞ –∫ —ç–ª–µ–º–µ–Ω—Ç—É
        function applyTranslation(element, keyPath, params = {}) {
            if (!element) return;
            const keys = keyPath.split('.');
            let translation = translations[currentLanguage];
            for (const key of keys) {
                if (translation && translation[key]) {
                    translation = translation[key];
                } else {
                    translation = undefined;
                    break;
                }
            }
            if (translation === undefined) {
                console.warn(`Translation not found for ${keyPath} in ${currentLanguage}`);
                return;
            }
            element.innerHTML = formatString(translation, params);
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤—Å–µ–≥–æ UI –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å —Ç–µ–∫—É—â–∏–º —è–∑—ã–∫–æ–º
        function updateAllTranslations() {
            // –≠–∫—Ä–∞–Ω –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏—è
            applyTranslation(document.querySelector('#welcomeScreen h2'), 'welcome.title');
            const welcomeTexts = document.querySelectorAll('#welcomeScreen p');
            if (welcomeTexts.length >= 7) {
                applyTranslation(welcomeTexts[0], 'welcome.text1');
                applyTranslation(welcomeTexts[1], 'welcome.text2');
                applyTranslation(welcomeTexts[2], 'welcome.text3');
                applyTranslation(welcomeTexts[3], 'welcome.text4');
                applyTranslation(welcomeTexts[4], 'welcome.text5');
                applyTranslation(welcomeTexts[5], 'welcome.text6');
                applyTranslation(welcomeTexts[6], 'welcome.text7');
            }
            
            // –ö–Ω–æ–ø–∫–∏ –Ω–∞ —ç–∫—Ä–∞–Ω–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏—è
            applyTranslation(document.getElementById('continueBtn'), 'buttons.continue');
            applyTranslation(document.getElementById('startBtn'), 'buttons.start');
            updateLangButtonTooltip();
            
            // –≠–∫—Ä–∞–Ω —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
            applyTranslation(document.querySelector('#saveScreen h2'), 'saveScreen.title');
            applyTranslation(document.querySelector('#saveScreen p'), 'saveScreen.text');
            applyTranslation(document.getElementById('loadSaveBtn'), 'buttons.loadSave');
            applyTranslation(document.getElementById('newGameBtn'), 'buttons.newGame');
            applyTranslation(document.getElementById('cancelSaveBtn'), 'buttons.cancel');
            
            // –≠–∫—Ä–∞–Ω Game Over
            applyTranslation(document.querySelector('#gameOverScreen h2'), 'gameOver.title');
            applyTranslation(document.getElementById('restartBtn'), 'buttons.restart');
            applyTranslation(document.getElementById('shareBtn'), 'buttons.share');
            
            // HUD
            applyTranslation(document.querySelector('.hud-item#coins i + span'), 'hud.coins', { value: coinsDisplay.textContent });
            applyTranslation(document.querySelector('.hud-item#clickPowerInfo i + span'), 'hud.clickPower', { value: clickPowerDisplay.textContent });
            applyTranslation(document.querySelector('.hud-item#critChanceInfo i + span'), 'hud.critChance', { value: critChanceDisplay.textContent });
            applyTranslation(document.querySelector('.hud-item#critMultiplierInfo i + span'), 'hud.critMultiplier', { value: critMultiplierDisplay.textContent });
            
            // –ù–∞–∑–≤–∞–Ω–∏–µ —Ç–µ–∫—É—â–µ–π –ª–æ–∫–∞—Ü–∏–∏
            applyTranslation(document.getElementById('gameTitle'), `gameTitle.${currentLocation}`);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∫–Ω–æ–ø–∫–∏ —É–ª—É—á—à–µ–Ω–∏–π
            if (document.getElementById('upgradeClickBtn')) {
                document.getElementById('upgradeClickBtn').title = translations[currentLanguage].tooltips.upgradeClick;
            }
            if (document.getElementById('upgradeHelperBtn')) {
                document.getElementById('upgradeHelperBtn').title = translations[currentLanguage].tooltips.upgradeHelper;
            }
            if (document.getElementById('upgradeCritChanceBtn')) {
                document.getElementById('upgradeCritChanceBtn').title = translations[currentLanguage].tooltips.upgradeCritChance;
            }
            if (document.getElementById('upgradeCritMultBtn')) {
                document.getElementById('upgradeCritMultBtn').title = translations[currentLanguage].tooltips.upgradeCritMult;
            }
            if (document.getElementById('upgradeHelperDmgBtn')) {
                document.getElementById('upgradeHelperDmgBtn').title = translations[currentLanguage].tooltips.upgradeHelperDmg;
            }
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–∏–π —è–∑—ã–∫
            localStorage.setItem('gameLanguage', currentLanguage);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä —Ç–µ–∫—Å—Ç
            const currentAU = totalDamageDealt / AU_TO_DAMAGE;
            const targetAU = locationRequirements[currentLocation].targetAU;
            const percentage = Math.min(100, (currentAU / targetAU) * 100);
            applyTranslation(document.getElementById('progressText'), 'progressText', {
                current: currentAU.toFixed(5),
                target: targetAU.toFixed(5),
                percent: percentage.toFixed(1)
            });
        }
        
        // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è tooltip –¥–ª—è –∫–Ω–æ–ø–∫–∏ –≤—ã–±–æ—Ä–∞ —è–∑—ã–∫–∞
        function updateLangButtonTooltip() {
            const langBtn = document.getElementById('langBtn-welcome');
            let tooltipText = '';
            
            switch(currentLanguage) {
                case 'ru':
                    tooltipText = '–¢–µ–∫—É—â–∏–π —è–∑—ã–∫: –†—É—Å—Å–∫–∏–π (üá∑üá∫) - –ù–∞–∂–º–∏—Ç–µ –¥–ª—è —Å–º–µ–Ω—ã —è–∑—ã–∫–∞';
                    break;
                case 'en':
                    tooltipText = 'Current language: English (üá¨üáß) - Click to change language';
                    break;
                case 'zh':
                    tooltipText = 'ÂΩìÂâçËØ≠Ë®Ä: ‰∏≠Êñá (üá®üá≥) - ÁÇπÂáªÊõ¥ÊîπËØ≠Ë®Ä';
                    break;
            }
            
            if (langBtn) {
                langBtn.title = tooltipText;
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ñ–ª–∞–≥–∞ —Ç–µ–∫—É—â–µ–≥–æ —è–∑—ã–∫–∞
        function updateLanguageFlag() {
            const flagElement = document.getElementById('currentLangFlag');
            if (flagElement) {
                switch(currentLanguage) {
                    case 'ru': flagElement.textContent = 'üá∑üá∫'; break; // –§–ª–∞–≥ –†–æ—Å—Å–∏–∏
                    case 'en': flagElement.textContent = 'üá¨üáß'; break; // –§–ª–∞–≥ –í–µ–ª–∏–∫–æ–±—Ä–∏—Ç–∞–Ω–∏–∏
                    case 'zh': flagElement.textContent = 'üá®üá≥'; break; // –§–ª–∞–≥ –ö–∏—Ç–∞—è
                }
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è —è–∑—ã–∫–∞
        function switchLanguage() {
            const languages = ['ru', 'en', 'zh'];
            const currentIndex = languages.indexOf(currentLanguage);
            const nextIndex = (currentIndex + 1) % languages.length;
            currentLanguage = languages[nextIndex];
            updateLanguageFlag();
            updateLangButtonTooltip();
            updateAllTranslations();
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–ª–∞–Ω–µ—Ç–∞—Ä–Ω–æ–≥–æ —Ñ–æ–Ω–∞
        planetBackground.init();
        // === –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –û–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π locations –ü–ï–†–ï–î –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º ===
        const locations = {
            mercury: { name: "‚òø –ú–µ—Ä–∫—É—Ä–∏–π", color: "#bb86fc", coinColor: "#a0d2ff", borderColor: "#4a55e0", blockColors: ['#2962ff', '#4fc3f7', '#bb86fc', '#f8bbd0'] },
            venus: { name: "‚ôÄ –í–µ–Ω–µ—Ä–∞", color: "#ffab91", coinColor: "#a0d2ff", borderColor: "#ff5722", blockColors: ['#ff5722', '#ff9800', '#ff5722', '#e91e63'] },
            earth: { name: "‚ôÅ –ó–µ–º–ª—è", color: "#80deea", coinColor: "#a0d2ff", borderColor: "#0288d1", blockColors: ['#0288d1', '#29b6f6', '#00bcd4', '#00e5ff'] },
            mars: { name: "‚ôÇ –ú–∞—Ä—Å", color: "#a5d6a7", coinColor: "#a0d2ff", borderColor: "#388e3c", blockColors: ['#388e3c', '#66bb6a', '#9ccc65', '#d4e157'] },
            jupiter: { name: "‚ôÉ –Æ–ø–∏—Ç–µ—Ä", color: "#ce93d8", coinColor: "#a0d2ff", borderColor: "#7b1fa2", blockColors: ['#7b1fa2', '#9c27b0', '#ab47bc', '#e1bee7'] },
            saturn: { name: "‚ôÑ –°–∞—Ç—É—Ä–Ω", color: "#ce93d8", coinColor: "#a0d2ff", borderColor: "#7b1fa2", blockColors: ['#7b1fa2', '#9c27b0', '#ab47bc', '#e1bee7'] },
            uranus: { name: "‚ôÖ –£—Ä–∞–Ω", color: "#ce93d8", coinColor: "#a0d2ff", borderColor: "#7b1fa2", blockColors: ['#7b1fa2', '#9c27b0', '#ab47bc', '#e1bee7'] },
            neptune: { name: "‚ôÜ –ù–µ–ø—Ç—É–Ω", color: "#ce93d8", coinColor: "#a0d2ff", borderColor: "#7b1fa2", blockColors: ['#7b1fa2', '#9c27b0', '#ab47bc', '#e1bee7'] },
            pluto: { name: "‚ôá –ü–ª—É—Ç–æ–Ω", color: "#ce93d8", coinColor: "#a0d2ff", borderColor: "#7b1fa2", blockColors: ['#7b1fa2', '#9c27b0', '#ab47bc', '#e1bee7'] }
        };
        // –û—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ –∏–≥—Ä—ã
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        // === –§–ê–ö–¢–ò–ß–ï–°–ö–ò–ï –†–ê–°–°–¢–û–Ø–ù–ò–Ø –ü–õ–ê–ù–ï–¢ –í –ê–°–¢–†–û–ù–û–ú–ò–ß–ï–°–ö–ò–• –ï–î–ò–ù–ò–¶–ê–• ===
        // 1 –∞.–µ. = 149,597,870.691 –∫–º
        const astronomicalUnits = {
            mercury: 0.38710,
            venus: 0.72333,
            earth: 1.00000,
            mars: 1.52366,
            jupiter: 5.20336,
            saturn: 9.53707,
            uranus: 19.19126,
            neptune: 30.06896,
            pluto: 39.48200
        };
        // –ü–ï–†–ï–°–ß–ò–¢–ê–ù–û –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–æ–π –∞—Å—Ç—Ä–æ–Ω–æ–º–∏—á–µ—Å–∫–æ–π –µ–¥–∏–Ω–∏—Ü—ã
        const AU_TO_DAMAGE = 149597870.691;
        const locationRequirements = {
            mercury: { 
                damageRequired: 0, 
                targetAU: astronomicalUnits.mercury,
                nextLocation: 'venus'
            },
            venus: { 
                damageRequired: 0, 
                targetAU: astronomicalUnits.venus,
                nextLocation: 'earth'
            },
            earth: { 
                damageRequired: 0, 
                targetAU: astronomicalUnits.earth,
                nextLocation: 'mars'
            },
            mars: { 
                damageRequired: 0, 
                targetAU: astronomicalUnits.mars,
                nextLocation: 'jupiter'
            },
            jupiter: { 
                damageRequired: 0, 
                targetAU: astronomicalUnits.jupiter,
                nextLocation: 'saturn'
            },
            saturn: { 
                damageRequired: 0, 
                targetAU: astronomicalUnits.saturn,
                nextLocation: 'uranus'
            },
            uranus: { 
                damageRequired: 0, 
                targetAU: astronomicalUnits.uranus,
                nextLocation: 'neptune'
            },
            neptune: { 
                damageRequired: 0, 
                targetAU: astronomicalUnits.neptune,
                nextLocation: 'pluto'
            },
            pluto: { 
                damageRequired: 0, 
                targetAU: astronomicalUnits.pluto,
                nextLocation: null
            }
        };
        let blockSpeed = isMobile ? 25 : 20;
        function getCurrentSpeed() {
            const baseSpeed = blockSpeed;
            const locationIndex = Object.keys(locationRequirements).indexOf(currentLocation);
            if (locationIndex < 3) {
                return baseSpeed * 0.85;
            }
            return baseSpeed;
        }
        const baseClickUpgradeCost = 80;
        const baseHelperUpgradeCost = 1500;
        const baseCritChanceCost = 500;
        const baseCritMultiplierCost = 800;
        const baseHelperDmgCost = 1000;
        const rareBlocks = {
            GOLD: {
                name: "–ó–æ–ª–æ—Ç–æ–π",
                chance: 0.03,
                multiplier: 8,
                healthMultiplier: 1.8,
                effect: "–ú–≥–Ω–æ–≤–µ–Ω–Ω—ã–π –±–æ–Ω—É—Å",
                className: "block-gold"
            },
            RAINBOW: {
                name: "–†–∞–¥—É–∂–Ω—ã–π", 
                chance: 0.02,
                multiplier: 5,
                healthMultiplier: 1.5,
                effect: "–£–≤–µ–ª–∏—á–µ–Ω–∏–µ —Å–∏–ª—ã",
                className: "block-rainbow"
            },
            CRYSTAL: {
                name: "–ö—Ä–∏—Å—Ç–∞–ª—å–Ω—ã–π",
                chance: 0.025,
                multiplier: 6,
                healthMultiplier: 1.6,
                effect: "–í—Ä–µ–º—è –ø–æ–º–æ—â–Ω–∏–∫–∞",
                className: "block-crystal"
            },
            MYSTERY: {
                name: "–ó–∞–≥–∞–¥–æ—á–Ω—ã–π",
                chance: 0.015,
                multiplier: 10,
                healthMultiplier: 2.0,
                effect: "–°–ª—É—á–∞–π–Ω—ã–π –±–æ–Ω—É—Å",
                className: "block-mystery"
            }
        };
        const balanceConfig = {
            baseHealth: 80,
            targetClicks: 70,
            healthRandomRange: { min: 0.8, max: 1.3 },
            damageProgression: {
                baseMultiplier: 1.15,
                diminishingReturns: 0.96,
                maxLevelEffect: 60
            },
            rewardMultiplier: 2.5,
            comboMultiplier: 0.25,
            randomBonusRange: { min: 0.8, max: 1.5 }
        };
        // === –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –£–¥–∞–ª–µ–Ω—ã –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∞–Ω–∏–º–∞—Ü–∏–∏ ===
        // === –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ===
        let coins = 0;
        let totalDamageDealt = 0;
        let clickPower = 1;
        let clickUpgradeLevel = 0;
        let gameActive = false;
        let currentLocation = 'mercury';
        let currentBlockHealth = 0;
        let currentBlock = null;
        let comboCount = 0;
        let lastDestroyTime = 0;
        const COMBO_TIME_WINDOW = isMobile ? 1500 : 2000;
        let helperActive = false;
        let helperTimeLeft = 0;
        const helperDuration = 60000;
        let helperInterval = null; // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è
        let helperUpgradeLevel = 0;
        const helperUpgradeMultiplier = 1.8;
        let critChance = 0.001; // –ù–∞—á–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ 0.1%
        let critMultiplier = 2.0;
        let helperDamageBonus = 0.3;
        let helperElement = null;
        let helperPosition = { x: 0, y: 0 };
        let bogoCoinBonus = 0; // –ë–æ–Ω—É—Å –∫ –∫—Ä–∏—Å—Ç–∞–ª–ª–∞–º –æ—Ç Bobo
        // === –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –î–æ–±–∞–≤–ª–µ–Ω—ã –Ω–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —É–ª—É—á—à–µ–Ω–∏–π ===
        let critChanceUpgradeLevel = 0;
        let critMultiplierUpgradeLevel = 0;
        // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü–µ—Ä–µ—Ä–∞–±–æ—Ç–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ gameMetrics
        let gameMetrics = {
            startTime: Date.now(),
            blocksDestroyed: 0,
            upgradesBought: 0,
            totalClicks: 0,
            sessions: 1
        };
        // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–π –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –º–µ—Ç—Ä–∏–∫–∞–º–∏
        function saveGameMetrics() {
            localStorage.setItem('gameMetrics', JSON.stringify({
                blocksDestroyed: gameMetrics.blocksDestroyed,
                upgradesBought: gameMetrics.upgradesBought,
                totalClicks: gameMetrics.totalClicks,
                sessions: gameMetrics.sessions,
                startTime: gameMetrics.startTime // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –°–æ—Ö—Ä–∞–Ω—è–µ–º startTime
            }));
        }
        function loadGameMetrics() {
            const saved = localStorage.getItem('gameMetrics');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    gameMetrics = {
                        startTime: data.startTime || Date.now(), // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è
                        blocksDestroyed: data.blocksDestroyed || 0,
                        upgradesBought: data.upgradesBought || 0,
                        totalClicks: data.totalClicks || 0,
                        sessions: (data.sessions || 0) + 1
                    };
                    saveGameMetrics();
                    return true;
                } catch (e) {
                    console.warn('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–µ—Ç—Ä–∏–∫', e);
                }
            }
            return false;
        }
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–µ—Ç—Ä–∏–∫ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
        loadGameMetrics();
        // === –û–ë–ù–û–í–õ–ï–ù–ù–´–ï –§–£–ù–ö–¶–ò–ò –ë–ê–õ–ê–ù–°–ò–†–û–í–ö–ò ===
        function calculateBlockHealth() {
            const currentReq = locationRequirements[currentLocation]; // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º currentReq
            const locationBonus = 1 + (currentReq.targetAU * 2);
            let baseHealth = balanceConfig.baseHealth * locationBonus;
            const targetHealth = clickPower * balanceConfig.targetClicks;
            const combinedHealth = (baseHealth + targetHealth) / 2;
            const randomFactor = balanceConfig.healthRandomRange.min + 
                                Math.random() * (balanceConfig.healthRandomRange.max - balanceConfig.healthRandomRange.min);
            return Math.floor(combinedHealth * randomFactor);
        }
        function calculateClickPower() {
            const basePower = 1;
            const upgradeBonus = clickUpgradeLevel;
            const diminishingEffect = Math.pow(balanceConfig.damageProgression.diminishingReturns, 
                                             Math.min(clickUpgradeLevel, balanceConfig.damageProgression.maxLevelEffect));
            const nonLinearGrowth = Math.sqrt(clickUpgradeLevel + 1);
            return basePower + (upgradeBonus * diminishingEffect * nonLinearGrowth * balanceConfig.damageProgression.baseMultiplier);
        }
        function getExpectedClicks(blockHealth, playerDamage) {
            return Math.ceil(blockHealth / playerDamage);
        }
        function getRareBlockType() {
            const rand = Math.random();
            let cumulativeChance = 0;
            for (const [type, block] of Object.entries(rareBlocks)) {
                cumulativeChance += block.chance;
                if (rand <= cumulativeChance) {
                    return type;
                }
            }
            return null;
        }
        function announceRareBlock(blockName) {
            const announce = document.createElement('div');
            announce.className = 'rare-block-announce';
            announce.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 1.8em;
                font-weight: bold;
                color: gold;
                z-index: 50;
                text-shadow: 0 0 10px black;
                animation: fadeInOut 2s;
            `;
            announce.textContent = `üåü ${blockName} –±–ª–æ–∫! üåü`;
            document.body.appendChild(announce);
            setTimeout(() => {
                if (announce.parentNode) {
                    document.body.removeChild(announce);
                }
            }, 2000);
        }
        // === –£–õ–£–ß–®–ï–ù–ù–ê–Ø –°–ò–°–¢–ï–ú–ê –°–û–•–†–ê–ù–ï–ù–ò–Ø ===
        function saveGame() {
          const saveData = {
            coins,
            clickPower,
            clickUpgradeLevel,
            critChance,
            critMultiplier,
            helperDamageBonus,
            helperUpgradeLevel,
            totalDamageDealt,
            currentLocation,
            bogoCoinBonus,
            gameActive: true,
            timestamp: Date.now(),
            // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –≤ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
            critChanceUpgradeLevel,
            critMultiplierUpgradeLevel
          };
          localStorage.setItem('cosmicBlocksSave', JSON.stringify(saveData));
          showTooltip(translations[currentLanguage].tooltips.saveSuccess);
          setTimeout(hideTooltip, 1500);
          updateContinueButton();
        }
        function loadGame() {
          const saved = localStorage.getItem('cosmicBlocksSave');
          if (saved) {
            try {
              const data = JSON.parse(saved);
              const saveAge = Date.now() - (data.timestamp || 0);
              const maxSaveAge = 30 * 24 * 60 * 60 * 1000;
              if (saveAge < maxSaveAge) {
                coins = data.coins || 0;
                clickPower = data.clickPower || 1;
                clickUpgradeLevel = data.clickUpgradeLevel || 0;
                critChance = data.critChance || 0.001;
                critMultiplier = data.critMultiplier || 2.0;
                helperDamageBonus = data.helperDamageBonus || 0.3;
                helperUpgradeLevel = data.helperUpgradeLevel || 0;
                totalDamageDealt = data.totalDamageDealt || 0;
                currentLocation = data.currentLocation || 'mercury';
                bogoCoinBonus = data.bogoCoinBonus || 0;
                // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ó–∞–≥—Ä—É–∂–∞–µ–º –Ω–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —Å –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å—é
                critChanceUpgradeLevel = data.critChanceUpgradeLevel || Math.round((critChance - 0.001) / 0.001);
                critMultiplierUpgradeLevel = data.critMultiplierUpgradeLevel || Math.round((critMultiplier - 2.0) / 0.2);
                return true;
              } else {
                console.log('–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–ª–æ');
                localStorage.removeItem('cosmicBlocksSave');
              }
            } catch (e) {
              console.warn('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è', e);
            }
          }
          return false;
        }
        function updateContinueButton() {
          const continueBtn = document.getElementById('continueBtn');
          if (continueBtn) {
            const hasSave = localStorage.getItem('cosmicBlocksSave') !== null;
            if (hasSave) {
              continueBtn.className = 'btn save-available';
              continueBtn.textContent = translations[currentLanguage].buttons.continue;
            } else {
              continueBtn.className = 'btn no-save';
              continueBtn.textContent = translations[currentLanguage].buttons.noSave;
            }
          }
        }
        // –ü–æ–ª—É—á–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã DOM
        const DOMElements = {
            coinsDisplay: document.getElementById("coins-value"),
            clickPowerDisplay: document.getElementById("clickPower-value"),
            critChanceDisplay: document.getElementById("critChance-value"),
            critMultiplierDisplay: document.getElementById("critMultiplier-value"),
            progressBar: document.getElementById("progressBar"),
            progressText: document.getElementById("progressText"),
            levelAnnounce: document.getElementById("levelAnnounce"),
            gameTitle: document.getElementById("gameTitle"),
            upgradeClickBtn: document.getElementById("upgradeClickBtn"),
            upgradeHelperBtn: document.getElementById("upgradeHelperBtn"),
            upgradeCritChanceBtn: document.getElementById("upgradeCritChanceBtn"),
            upgradeCritMultBtn: document.getElementById("upgradeCritMultBtn"),
            upgradeHelperDmgBtn: document.getElementById("upgradeHelperDmgBtn"),
            gameOverScreen: document.getElementById("gameOverScreen"),
            finalScoreDisplay: document.getElementById("finalScore"),
            tooltip: document.getElementById("tooltip"),
            welcomeScreen: document.getElementById("welcomeScreen"),
            saveScreen: document.getElementById("saveScreen"),
            header: document.getElementById("header"),
            gameArea: document.getElementById("gameArea"),
            particlesCanvas: document.getElementById("particlesCanvas"),
            startBtn: document.getElementById("startBtn"),
            continueBtn: document.getElementById("continueBtn"),
            loadSaveBtn: document.getElementById("loadSaveBtn"),
            newGameBtn: document.getElementById("newGameBtn"),
            cancelSaveBtn: document.getElementById("cancelSaveBtn"),
            restartBtn: document.getElementById("restartBtn"),
            shareBtn: document.getElementById("shareBtn"),
            saveBtn: document.getElementById("saveBtn"),
            langBtnWelcome: document.getElementById("langBtn-welcome")
        };
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –≤—Å–µ—Ö –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
        let missingElements = [];
        Object.entries(DOMElements).forEach(([name, element]) => {
            if (!element) missingElements.push(name);
        });
        if (missingElements.length > 0) {
            console.error("–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç —ç–ª–µ–º–µ–Ω—Ç—ã:", missingElements.join(", "));
            return;
        }
        // –ü—Ä–∏—Å–≤–∞–∏–≤–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        const {
            coinsDisplay, clickPowerDisplay, critChanceDisplay, critMultiplierDisplay, progressBar, progressText,
            levelAnnounce, gameTitle, upgradeClickBtn, upgradeHelperBtn, 
            upgradeCritChanceBtn, upgradeCritMultBtn, upgradeHelperDmgBtn, 
            gameOverScreen, finalScoreDisplay, tooltip, welcomeScreen, saveScreen,
            header, gameArea, particlesCanvas, startBtn, continueBtn, loadSaveBtn,
            newGameBtn, cancelSaveBtn, restartBtn, shareBtn, saveBtn, langBtnWelcome
        } = DOMElements;
        // === –û–ë–ù–û–í–õ–ï–ù–ù–´–ô –≠–§–§–ï–ö–¢ –í–ó–†–´–í–ê –° –£–í–ï–õ–ò–ß–ï–ù–ù–û–ô –û–ë–õ–ê–°–¢–¨–Æ ===
        function createExplosion(block) {
            const rect = block.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            // –£–í–ï–õ–ò–ß–ï–ù–ù–´–ô –†–ê–ó–ú–ï–† –í–ó–†–´–í–ê
            const explosionSize = isMobile ? 150 : 200;
            // –°–æ–∑–¥–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –≤–∑—Ä—ã–≤
            const explosion = document.createElement('div');
            explosion.className = 'explosion';
            explosion.style.left = centerX + 'px';
            explosion.style.top = centerY + 'px';
            explosion.style.width = explosionSize + 'px';
            explosion.style.height = explosionSize + 'px';
            document.body.appendChild(explosion);
            // –£–í–ï–õ–ò–ß–ï–ù–ù–û–ï –ö–û–õ–ò–ß–ï–°–¢–í–û –ß–ê–°–¢–ò–¶
            const particleCount = isMobile ? 20 : 25;
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'explosion-particle';
                particle.style.left = centerX + 'px';
                particle.style.top = centerY + 'px';
                // –£–í–ï–õ–ò–ß–ï–ù–ù–´–ô –†–ê–ó–ú–ï–† –ß–ê–°–¢–ò–¶
                const particleSize = isMobile ? 10 : 12;
                particle.style.width = particleSize + 'px';
                particle.style.height = particleSize + 'px';
                // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: locations —Ç–µ–ø–µ—Ä—å –¥–æ—Å—Ç—É–ø–Ω–∞
                const location = locations[currentLocation];
                particle.style.backgroundColor = location.blockColors[Math.floor(Math.random() * location.blockColors.length)];
                // –£–í–ï–õ–ò–ß–ï–ù–ù–û–ï –†–ê–°–°–¢–û–Ø–ù–ò–ï –†–ê–ó–õ–ï–¢–ê
                const angle = Math.random() * Math.PI * 2;
                const distance = 50 + Math.random() * 100;
                const tx = Math.cos(angle) * distance;
                const ty = Math.sin(angle) * distance;
                particle.style.setProperty('--tx', tx + 'px');
                particle.style.setProperty('--ty', ty + 'px');
                document.body.appendChild(particle);
                // –£–¥–∞–ª—è–µ–º —á–∞—Å—Ç–∏—Ü—ã –ø–æ—Å–ª–µ –∞–Ω–∏–º–∞—Ü–∏–∏
                setTimeout(() => {
                    if (particle.parentNode) {
                        document.body.removeChild(particle);
                    }
                }, 800);
            }
            // –£–¥–∞–ª—è–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –≤–∑—Ä—ã–≤ –ø–æ—Å–ª–µ –∞–Ω–∏–º–∞—Ü–∏–∏
            setTimeout(() => {
                if (explosion.parentNode) {
                    document.body.removeChild(explosion);
                }
            }, 600);
        }
        // === –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –°–ò–°–¢–ï–ú–ê –ü–†–û–ì–†–ï–°–°–ê –í –ê–°–¢–†–û–ù–û–ú–ò–ß–ï–°–ö–ò–• –ï–î–ò–ù–ò–¶–ê–• ===
        function updateProgressBar() {
            const currentReq = locationRequirements[currentLocation];
            const nextLocation = currentReq.nextLocation;
            const currentAU = totalDamageDealt / AU_TO_DAMAGE;
            const targetAU = currentReq.targetAU;
            const percentage = Math.min(100, (currentAU / targetAU) * 100);
            progressBar.style.width = percentage + '%';
            applyTranslation(progressText, 'progressText', {
                current: currentAU.toFixed(5),
                target: targetAU.toFixed(5),
                percent: percentage.toFixed(1)
            });
        }
        function checkLocationUpgrade() {
            const currentReq = locationRequirements[currentLocation];
            const nextLocation = currentReq.nextLocation;
            const currentAU = totalDamageDealt / AU_TO_DAMAGE;
            const targetAU = currentReq.targetAU;
            if (nextLocation && currentAU >= targetAU) {
                // –ü–û–õ–ù–û–°–¢–¨–Æ –†–ê–ó–ë–õ–û–ö–ò–†–û–í–ê–ù–´ –í–°–ï –õ–û–ö–ê–¶–ò–ò
                setLocation(nextLocation);
                showTooltip(formatString(translations[currentLanguage].locationProgress.unlocked, { location: locations[nextLocation].name }));
                setTimeout(hideTooltip, 3000);
            }
            updateProgressBar();
        }
        // === –û–ë–ù–û–í–õ–ï–ù–ù–´–ï –§–£–ù–ö–¶–ò–ò –¢–ï–ö–°–¢–ê –£–†–û–ù–ê –ò –ë–û–ù–£–°–û–í ===
        function createDamageText(damage, block, color = '#ff4444') {
            const rect = block.getBoundingClientRect();
            const text = document.createElement('div');
            text.className = 'damage-text';
            text.textContent = `-${damage}`;
            text.style.color = color;
            let left = rect.left + rect.width / 2;
            let top = rect.top;
            const textWidth = 100;
            if (left < textWidth / 2) left = textWidth / 2;
            if (left > window.innerWidth - textWidth / 2) left = window.innerWidth - textWidth / 2;
            if (top < 50) top = 50;
            text.style.left = left + 'px';
            text.style.top = top + 'px';
            document.body.appendChild(text);
            let opacity = 1;
            let yPos = parseInt(text.style.top);
            function animate() {
                opacity -= 0.02;
                yPos -= 2;
                text.style.opacity = opacity;
                text.style.top = yPos + 'px';
                if (opacity > 0) {
                    requestAnimationFrame(animate);
                } else {
                    if (text.parentNode) {
                        document.body.removeChild(text);
                    }
                }
            }
            animate();
        }
        function showComboText(combo, bonus, block) {
            const rect = block.getBoundingClientRect();
            const text = document.createElement('div');
            text.className = 'combo-text';
            text.textContent = formatString(translations[currentLanguage].tooltips.combo, { count: combo, bonus: bonus });
            let left = rect.left + rect.width / 2;
            let top = rect.top;
            const textWidth = 150;
            if (left < textWidth / 2) left = textWidth / 2;
            if (left > window.innerWidth - textWidth / 2) left = window.innerWidth - textWidth / 2;
            if (top < 50) top = 50;
            text.style.left = left + 'px';
            text.style.top = top + 'px';
            document.body.appendChild(text);
            setTimeout(() => {
                if (text.parentNode) {
                    document.body.removeChild(text);
                }
            }, 1000);
        }
        function showRewardText(reward, block) {
            const rect = block.getBoundingClientRect();
            const text = document.createElement('div');
            text.className = 'reward-text';
            text.textContent = formatString(translations[currentLanguage].tooltips.reward, { reward: reward });
            let left = rect.left + rect.width / 2;
            let top = rect.top + rect.height / 2;
            const textWidth = 120;
            if (left < textWidth / 2) left = textWidth / 2;
            if (left > window.innerWidth - textWidth / 2) left = window.innerWidth - textWidth / 2;
            if (top < 50) top = 50;
            text.style.left = left + 'px';
            text.style.top = top + 'px';
            document.body.appendChild(text);
            setTimeout(() => {
                if (text.parentNode) {
                    document.body.removeChild(text);
                }
            }, 1500);
        }
        // === –§–£–ù–ö–¶–ò–ò –†–ê–ë–û–¢–´ –° –ü–û–ú–û–©–ù–ò–ö–û–ú BOBO ===
        function moveHelperToRandomPosition() {
            if (!helperElement) return;
            // –ü–æ–ª—É—á–∞–µ–º –ø–æ–∑–∏—Ü–∏—é —Ç–µ–∫—É—â–µ–≥–æ –±–ª–æ–∫–∞
            let blockRect = { left: window.innerWidth/2, top: window.innerHeight/2 };
            if (currentBlock) {
                blockRect = currentBlock.getBoundingClientRect();
            }
            // –ù–∞—Ö–æ–¥–∏–º –ø–æ–∑–∏—Ü–∏—é –≤–¥–∞–ª–∏ –æ—Ç –±–ª–æ–∫–∞
            let attempts = 0;
            let validPosition = false;
            const safeDistance = 150;
            while (!validPosition && attempts < 20) {
                attempts++;
                // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–ª—É—á–∞–π–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
                const randomX = Math.random() * (window.innerWidth - 60) + 30;
                const randomY = Math.random() * (window.innerHeight - 120) + 60; // –ò–∑–±–µ–≥–∞–µ–º –≤–µ—Ä—Ö–Ω–µ–π —á–∞—Å—Ç–∏ —Å UI
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç –±–ª–æ–∫–∞
                const distance = Math.sqrt(
                    Math.pow(randomX - (blockRect.left + blockRect.width/2), 2) + 
                    Math.pow(randomY - (blockRect.top + blockRect.height/2), 2)
                );
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–∑–∏—Ü–∏—è –Ω–µ —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ –∫ –∫—Ä–∞—è–º –∏ –Ω–µ –ø–µ—Ä–µ–∫—Ä—ã–≤–∞–µ—Ç UI
                const safeFromEdges = randomX > 60 && randomX < window.innerWidth - 60 && 
                                    randomY > 100 && randomY < window.innerHeight - 60;
                if (distance > safeDistance && safeFromEdges) {
                    helperPosition = { x: randomX, y: randomY };
                    validPosition = true;
                }
            }
            // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ —Ö–æ—Ä–æ—à—É—é –ø–æ–∑–∏—Ü–∏—é, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é –∏–ª–∏ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—É—é
            if (!validPosition) {
                helperPosition = {
                    x: window.innerWidth * 0.7,
                    y: window.innerHeight * 0.7
                };
            }
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é
            helperElement.style.left = helperPosition.x + 'px';
            helperElement.style.top = helperPosition.y + 'px';
        }
        function createHelperElement() {
            if (helperElement && helperElement.parentNode) {
                document.body.removeChild(helperElement);
            }
            helperElement = document.createElement('div');
            helperElement.className = 'helper';
            document.body.appendChild(helperElement);
            moveHelperToRandomPosition();
            // –î–æ–±–∞–≤–ª—è–µ–º –ø–ª–∞–≤–Ω–æ–µ –ø–æ—è–≤–ª–µ–Ω–∏–µ
            helperElement.style.opacity = '0';
            setTimeout(() => {
                if (helperElement) helperElement.style.opacity = '1';
            }, 100);
        }
        // === –§–£–ù–ö–¶–ò–Ø –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–ò –õ–£–ß–ê BOBO ===
        function createHelperEffect() {
            if (!currentBlock || !helperElement) return;
            
            const blockRect = currentBlock.getBoundingClientRect();
            const helperRect = helperElement.getBoundingClientRect();
            
            // –°–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ –ª—É—á–∞
            const beamContainer = document.createElement('div');
            beamContainer.className = 'helper-beam';
            beamContainer.style.position = 'absolute';
            beamContainer.style.zIndex = '13';
            document.body.appendChild(beamContainer);
            
            // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é –∏ –∫–æ–Ω–µ—á–Ω—É—é —Ç–æ—á–∫–∏ –ª—É—á–∞
            const startX = helperRect.left + helperRect.width / 2;
            const startY = helperRect.top + helperRect.height / 2;
            const endX = blockRect.left + blockRect.width / 2;
            const endY = blockRect.top + blockRect.height / 2;
            
            // –°–æ–∑–¥–∞–µ–º canvas –¥–ª—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è –ª—É—á–∞
            const canvas = document.createElement('canvas');
            const maxSize = Math.max(window.innerWidth, window.innerHeight);
            canvas.width = maxSize;
            canvas.height = maxSize;
            beamContainer.appendChild(canvas);
            
            // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
            beamContainer.style.left = '0px';
            beamContainer.style.top = '0px';
            
            const ctx = canvas.getContext('2d');
            
            // –ê–Ω–∏–º–∞—Ü–∏—è –ª—É—á–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º requestAnimationFrame
            let progress = 0;
            const animationDuration = 300; // –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∞–Ω–∏–º–∞—Ü–∏–∏ –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö
            const startTime = Date.now();
            
            function animateBeam() {
                const currentTime = Date.now();
                const elapsed = currentTime - startTime;
                progress = Math.min(elapsed / animationDuration, 1);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (progress > 0) {
                    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ç–µ–∫—É—â—É—é –ø–æ–∑–∏—Ü–∏—é –ª—É—á–∞
                    const currentX = startX + (endX - startX) * progress;
                    const currentY = startY + (endY - startY) * progress;
                    
                    // –°–æ–∑–¥–∞–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è –ª—É—á–∞
                    const gradient = ctx.createLinearGradient(startX, startY, currentX, currentY);
                    gradient.addColorStop(0, 'rgba(105, 240, 174, 0.9)');
                    gradient.addColorStop(0.7, 'rgba(105, 240, 174, 0.5)');
                    gradient.addColorStop(1, 'rgba(105, 240, 174, 0)');
                    
                    // –†–∏—Å—É–µ–º –ª—É—á
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(currentX, currentY);
                    ctx.lineWidth = 4 + (4 * (1 - progress)); // –õ—É—á —Å—É–∂–∞–µ—Ç—Å—è –∫ –∫–æ–Ω—Ü—É
                    ctx.strokeStyle = gradient;
                    ctx.stroke();
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º —Å–≤–µ—Ç—è—â–∏–π—Å—è —ç—Ñ—Ñ–µ–∫—Ç
                    ctx.beginPath();
                    ctx.arc(currentX, currentY, 8 * (1 - progress), 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(105, 240, 174, ${0.7 * (1 - progress)})`;
                    ctx.fill();
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animateBeam);
                } else {
                    // –£–¥–∞–ª—è–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –ø–æ—Å–ª–µ –æ–∫–æ–Ω—á–∞–Ω–∏—è –∞–Ω–∏–º–∞—Ü–∏–∏
                    setTimeout(() => {
                        if (beamContainer.parentNode) {
                            document.body.removeChild(beamContainer);
                        }
                    }, 200);
                }
            }
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é
            animateBeam();
            
            // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –∑–≤—É–∫ –∞—Ç–∞–∫–∏
            playSound('helperSound');
            
            // –≠—Ñ—Ñ–µ–∫—Ç –ø–æ–ø–∞–¥–∞–Ω–∏—è
            setTimeout(() => {
                const hitEffect = document.createElement('div');
                hitEffect.style.position = 'absolute';
                hitEffect.style.left = (endX - 10) + 'px';
                hitEffect.style.top = (endY - 10) + 'px';
                hitEffect.style.width = '20px';
                hitEffect.style.height = '20px';
                hitEffect.style.background = 'radial-gradient(circle, #69f0ae, transparent)';
                hitEffect.style.borderRadius = '50%';
                hitEffect.style.zIndex = '15';
                hitEffect.style.opacity = '0.8';
                document.body.appendChild(hitEffect);
                
                // –ó–∞—Ç—É—Ö–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞
                let opacity = 0.8;
                const fadeOut = setInterval(() => {
                    opacity -= 0.1;
                    hitEffect.style.opacity = opacity;
                    if (opacity <= 0) {
                        clearInterval(fadeOut);
                        if (hitEffect.parentNode) document.body.removeChild(hitEffect);
                    }
                }, 30);
            }, animationDuration);
        }
        
        // === –§–£–ù–ö–¶–ò–Ø –ê–ö–¢–ò–í–ê–¶–ò–ò BOBO –° –ë–û–ù–£–°–û–ú –ö –ö–†–ò–°–¢–ê–õ–õ–ê–ú ===
        function activateHelper() {
            if (helperActive) return;
            helperActive = true;
            helperTimeLeft = helperDuration;
            bogoCoinBonus = 0.2; // +20% –∫ –∫—Ä–∏—Å—Ç–∞–ª–ª–∞–º
            // –°–æ–∑–¥–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç –ø–æ–º–æ—â–Ω–∏–∫–∞
            createHelperElement();
            helperInterval = setInterval(() => {
                if (helperActive && currentBlock && gameActive) {
                    helperAttack();
                }
            }, 1500);
            const helperTimer = setInterval(() => {
                if (!helperActive) {
                    clearInterval(helperTimer);
                    return;
                }
                helperTimeLeft -= 1000;
                if (helperTimeLeft <= 0) {
                    helperActive = false;
                    clearInterval(helperInterval);
                    clearInterval(helperTimer);
                    bogoCoinBonus = 0; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –±–æ–Ω—É—Å –∫ –∫—Ä–∏—Å—Ç–∞–ª–ª–∞–º
                    // –ü–ª–∞–≤–Ω–æ–µ –∏—Å—á–µ–∑–∞–Ω–∏–µ –ø–æ–º–æ—â–Ω–∏–∫–∞
                    if (helperElement) {
                        helperElement.style.opacity = '0';
                        setTimeout(() => {
                            if (helperElement && helperElement.parentNode) {
                                document.body.removeChild(helperElement);
                                helperElement = null;
                            }
                        }, 300);
                    }
                    updateUpgradeButtons();
                    showTooltip(translations[currentLanguage].tooltips.helperEnd);
                    setTimeout(hideTooltip, 1500);
                }
            }, 1000);
            updateUpgradeButtons();
            updateHUD();
            showTooltip(translations[currentLanguage].tooltips.helperAvailable);
            setTimeout(hideTooltip, 2500);
            saveGame();
        }
        function helperAttack() {
            if (!currentBlock || !helperActive || !helperElement) return;
            // –°–æ–∑–¥–∞–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –∞—Ç–∞–∫–∏
            createHelperEffect();
            const baseHelperDmg = clickPower * (1 + helperDamageBonus);
            const upgradedHelperDmg = baseHelperDmg * (1 + helperUpgradeLevel * 0.2);
            currentBlockHealth -= upgradedHelperDmg;
            totalDamageDealt += upgradedHelperDmg;
            gameMetrics.totalClicks++;
            createDamageText(Math.round(upgradedHelperDmg), currentBlock, '#69f0ae');
            checkLocationUpgrade();
            if (currentBlockHealth <= 0) {
                destroyBlock(currentBlock);
            } else {
                currentBlock.textContent = Math.floor(currentBlockHealth);
                updateCracks(currentBlock, currentBlockHealth);
            }
        }
        // === –û–°–¢–ê–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò –ò–ì–†–´ ===
        function setLocation(loc) {
            currentLocation = loc;
            applyTranslation(gameTitle, `gameTitle.${loc}`);
            if (header) header.style.borderColor = locations[loc].borderColor;
            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–ª–∞–Ω–µ—Ç–∞—Ä–Ω—ã–π —Ñ–æ–Ω
            planetBackground.setPlanet(loc);
            if (levelAnnounce) {
                levelAnnounce.textContent = locations[loc].name;
                levelAnnounce.style.color = locations[loc].color;
                levelAnnounce.style.opacity = "1";
                setTimeout(() => {
                    levelAnnounce.style.opacity = "0";
                }, 2000);
            }
            updateProgressBar();
        }
        function updateCoins() {
            if (coinsDisplay) coinsDisplay.textContent = Math.floor(coins).toLocaleString();
            updateUpgradeButtons();
        }
        function updateHUD() {
            if (coinsDisplay) coinsDisplay.textContent = Math.floor(coins).toLocaleString();
            if (clickPowerDisplay) clickPowerDisplay.textContent = Math.round(clickPower);
            if (critChanceDisplay) critChanceDisplay.textContent = `${(critChance * 100).toFixed(1)}%`;
            if (critMultiplierDisplay) critMultiplierDisplay.textContent = `x${critMultiplier.toFixed(1)}`;
        }
        // –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –û–ë–ù–û–í–õ–ï–ù–ò–Ø –ö–ù–û–ü–û–ö –° –ü–†–û–ü–û–†–¶–ò–û–ù–ê–õ–¨–ù–´–ú –†–û–°–¢–û–ú –°–¢–û–ò–ú–û–°–¢–ò
        function updateUpgradeButtons() {
            const clickCost = Math.floor(baseClickUpgradeCost * Math.pow(1.5, clickUpgradeLevel));
            if (upgradeClickBtn) {
                upgradeClickBtn.querySelector('.upgrade-cost').textContent = clickCost.toLocaleString();
                if (coins >= clickCost) {
                    upgradeClickBtn.className = "upgrade-btn btn-available";
                } else {
                    upgradeClickBtn.className = "upgrade-btn btn-unavailable";
                }
            }
            const helperCost = Math.floor(baseHelperUpgradeCost * Math.pow(1.4, helperUpgradeLevel));
            if (upgradeHelperBtn) {
                upgradeHelperBtn.querySelector('.upgrade-cost').textContent = helperCost.toLocaleString();
                if (coins >= helperCost && !helperActive) {
                    upgradeHelperBtn.className = "upgrade-btn btn-available";
                } else {
                    upgradeHelperBtn.className = "upgrade-btn btn-unavailable";
                }
            }
            // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ —Å—Ç–æ–∏–º–æ—Å—Ç–∏
            const critChanceCost = Math.floor(baseCritChanceCost * Math.pow(1.3, critChanceUpgradeLevel));
            if (upgradeCritChanceBtn) {
                upgradeCritChanceBtn.querySelector('.upgrade-cost').textContent = critChanceCost.toLocaleString();
                if (coins >= critChanceCost) {
                    upgradeCritChanceBtn.className = "upgrade-btn btn-available";
                } else {
                    upgradeCritChanceBtn.className = "upgrade-btn btn-unavailable";
                }
            }
            const critMultiplierCost = Math.floor(baseCritMultiplierCost * Math.pow(1.25, critMultiplierUpgradeLevel));
            if (upgradeCritMultBtn) {
                upgradeCritMultBtn.querySelector('.upgrade-cost').textContent = critMultiplierCost.toLocaleString();
                if (coins >= critMultiplierCost) {
                    upgradeCritMultBtn.className = "upgrade-btn btn-available";
                } else {
                    upgradeCritMultBtn.className = "upgrade-btn btn-unavailable";
                }
            }
            const helperDmgCost = Math.floor(baseHelperDmgCost * Math.pow(helperUpgradeMultiplier, helperUpgradeLevel));
            if (upgradeHelperDmgBtn) {
                upgradeHelperDmgBtn.querySelector('.upgrade-cost').textContent = helperDmgCost.toLocaleString();
                if (coins >= helperDmgCost) {
                    upgradeHelperDmgBtn.className = "upgrade-btn btn-available";
                } else {
                    upgradeHelperDmgBtn.className = "upgrade-btn btn-unavailable";
                }
            }
        }
        function buyClickPower() {
            const cost = Math.floor(baseClickUpgradeCost * Math.pow(1.5, clickUpgradeLevel));
            if (coins >= cost) {
                coins -= cost;
                clickUpgradeLevel += 1;
                clickPower = calculateClickPower();
                gameMetrics.upgradesBought++;
                updateCoins();
                updateHUD();
                playSound('upgradeSound');
                showTooltip(formatString(translations[currentLanguage].tooltips.clickPowerUpgrade, { power: Math.round(clickPower) }));
                setTimeout(hideTooltip, 1500);
                saveGame();
            }
        }
        function buyHelper() {
            const cost = Math.floor(baseHelperUpgradeCost * Math.pow(1.4, helperUpgradeLevel));
            if (coins >= cost && !helperActive) {
                coins -= cost;
                activateHelper();
                updateCoins();
                updateHUD();
                saveGame();
            }
        }
        // === –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –ü–û–ö–£–ü–ö–ò –®–ê–ù–°–ê –ö–†–ò–¢–ê ===
        function buyCritChance() {
            const cost = Math.floor(baseCritChanceCost * Math.pow(1.3, critChanceUpgradeLevel));
            if (coins >= cost) {
                coins -= cost;
                critChance = Math.min(1.0, critChance + 0.001);
                critChanceUpgradeLevel++; // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —É—Ä–æ–≤–µ–Ω—å —É–ª—É—á—à–µ–Ω–∏—è
                gameMetrics.upgradesBought++;
                updateCoins();
                updateHUD();
                playSound('upgradeSound');
                showTooltip(formatString(translations[currentLanguage].tooltips.critChanceUpgrade, { chance: (critChance * 100).toFixed(1) }));
                setTimeout(hideTooltip, 1500);
                saveGame();
            }
        }
        function buyCritMultiplier() {
            const cost = Math.floor(baseCritMultiplierCost * Math.pow(1.25, critMultiplierUpgradeLevel));
            if (coins >= cost) {
                coins -= cost;
                critMultiplier += 0.2;
                critMultiplierUpgradeLevel++; // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —É—Ä–æ–≤–µ–Ω—å —É–ª—É—á—à–µ–Ω–∏—è
                gameMetrics.upgradesBought++;
                updateCoins();
                updateHUD();
                playSound('upgradeSound');
                showTooltip(formatString(translations[currentLanguage].tooltips.critMultUpgrade, { mult: critMultiplier.toFixed(1) }));
                setTimeout(hideTooltip, 1500);
                saveGame();
            }
        }
        function buyHelperDamage() {
            const cost = Math.floor(baseHelperDmgCost * Math.pow(helperUpgradeMultiplier, helperUpgradeLevel));
            if (coins >= cost) {
                coins -= cost;
                helperUpgradeLevel += 1;
                gameMetrics.upgradesBought++;
                updateCoins();
                updateHUD();
                playSound('upgradeSound');
                showTooltip(formatString(translations[currentLanguage].tooltips.helperDmgUpgrade, { level: helperUpgradeLevel }));
                setTimeout(hideTooltip, 1500);
                saveGame();
            }
        }
        function updateCracks(block, health) {
            if (!block) return;
            const existingCrack = block.querySelector('.crack-overlay');
            if (existingCrack) {
                block.removeChild(existingCrack);
            }
            const maxHealth = parseInt(block.dataset.maxHealth);
            const damageRatio = 1 - (health / maxHealth);
            if (damageRatio > 0.7) {
                addCracks(block, 'crack-3');
            } else if (damageRatio > 0.4) {
                addCracks(block, 'crack-2');
            } else if (damageRatio > 0.1) {
                addCracks(block, 'crack-1');
            }
        }
        function addCracks(block, crackLevel) {
            const crackOverlay = document.createElement('div');
            crackOverlay.className = `crack-overlay ${crackLevel}`;
            block.appendChild(crackOverlay);
        }
        function playSound(soundId) {
            const sound = document.getElementById(soundId);
            if (sound) {
                sound.currentTime = 0;
                sound.play().catch(e => {});
            }
        }
        function hitBlock(block, damage) {
            if (!gameActive) return;
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
            playSound('clickSound');
            block.style.transform = 'translateX(-50%) scale(0.85)';
            setTimeout(() => {
                block.style.transform = 'translateX(-50%) scale(1)';
            }, 100);
            let finalDamage = Math.round(damage);
            let isCrit = false;
            if (Math.random() < critChance) {
                finalDamage = Math.round(damage * critMultiplier);
                isCrit = true;
                 document.dispatchEvent(new Event('critDamage'));
            }
            currentBlockHealth -= finalDamage;
            totalDamageDealt += finalDamage;
            gameMetrics.totalClicks++;
            createDamageText(finalDamage, block, isCrit ? '#FFD700' : '#ff4444');
            checkLocationUpgrade();
            if (currentBlockHealth <= 0) {
                destroyBlock(block);
            } else {
                block.textContent = Math.floor(currentBlockHealth);
                updateCracks(block, currentBlockHealth);
            }
        }
        function destroyBlock(block) {
            const now = Date.now();
            if (now - lastDestroyTime < COMBO_TIME_WINDOW) {
                comboCount++;
            } else {
                comboCount = 1;
            }
            lastDestroyTime = now;
            const baseReward = 25 + (locationRequirements[currentLocation].targetAU * 100);
            let reward = Math.floor(baseReward * balanceConfig.rewardMultiplier);
            const randomBonus = balanceConfig.randomBonusRange.min + 
                               Math.random() * (balanceConfig.randomBonusRange.max - balanceConfig.randomBonusRange.min);
            reward = Math.floor(reward * randomBonus);
            // –ü—Ä–∏–º–µ–Ω—è–µ–º –±–æ–Ω—É—Å –æ—Ç Bobo
            if (bogoCoinBonus > 0) {
                reward = Math.floor(reward * (1 + bogoCoinBonus));
            }
            let isRare = false;
            let rareType = null;
            for (const type in rareBlocks) {
                if (block.classList.contains(rareBlocks[type].className)) {
                    isRare = true;
                    rareType = type;
                    reward = Math.floor(reward * rareBlocks[type].multiplier);
                    break;
                }
            }
            if (comboCount > 1) {
                const comboBonus = Math.floor(reward * (comboCount * balanceConfig.comboMultiplier));
                reward += comboBonus;
                showComboText(comboCount, comboBonus, block);
                playSound('comboSound');
            }
            coins += reward;
            gameMetrics.blocksDestroyed++;
            updateCoins();
            updateHUD();
            playSound('breakSound');
            showRewardText(reward, block);
            // –°–æ–∑–¥–∞–µ–º —ç—Ñ—Ñ–µ–∫—Ç –≤–∑—Ä—ã–≤–∞ –≤ —Ü–µ–Ω—Ç—Ä–µ –±–ª–æ–∫–∞
            createExplosion(block);
            if (gameArea.contains(block)) {
                gameArea.removeChild(block);
            }
            currentBlock = null;
            currentBlockHealth = 0;
            setTimeout(() => {
                if (gameActive) {
                    createMovingBlock();
                }
            }, 500);
        }
        function getBlockSize() {
            const baseSize = isMobile ? 80 : 60;
            const locationIndex = Object.keys(locationRequirements).indexOf(currentLocation);
            if (locationIndex < 3) {
                return baseSize * 1.2;
            }
            return baseSize * (1 + locationIndex * 0.15);
        }
        function createMovingBlock() {
            if (currentBlock && gameArea.contains(currentBlock)) {
                gameArea.removeChild(currentBlock);
            }
            const blockHealth = calculateBlockHealth();
            currentBlockHealth = blockHealth;
            const block = document.createElement("div");
            block.className = "moving-block";
            const size = getBlockSize();
            block.style.width = size + "px";
            block.style.height = size + "px";
            block.style.bottom = "0px";
            block.dataset.maxHealth = blockHealth;
            const theme = locations[currentLocation];
            const colorIndex = Math.floor(Math.random() * theme.blockColors.length);
            let isRare = false;
            let rareType = null;
            const potentialRareType = getRareBlockType();
            if (potentialRareType) {
                isRare = true;
                rareType = potentialRareType;
                const rareBlock = rareBlocks[rareType];
                block.classList.add(rareBlock.className);
                currentBlockHealth = Math.floor(currentBlockHealth * rareBlock.healthMultiplier);
                block.innerHTML = `üåü<div style="font-size: 0.35em; margin-top: 1px; line-height: 1.1;">${rareBlock.name}</div>`;
                announceRareBlock(rareBlock.name);
            } else {
                block.style.background = `linear-gradient(135deg, ${theme.blockColors[colorIndex]}, ${theme.blockColors[(colorIndex + 1) % theme.blockColors.length]})`;
                block.style.boxShadow = `0 0 15px ${theme.blockColors[colorIndex]}`;
                block.style.border = `2px solid ${theme.borderColor}`;
                block.textContent = blockHealth;
            }
            const expectedClicks = getExpectedClicks(currentBlockHealth, clickPower);
            block.addEventListener('click', () => hitBlock(block, clickPower));
            block.addEventListener('touchstart', (e) => {
                e.preventDefault();
                hitBlock(block, clickPower);
            }, { passive: false });
            gameArea.appendChild(block);
            currentBlock = block;
            animateBlock(block);
        }
        function animateBlock(block) {
            if (!gameActive) return;
            const speed = getCurrentSpeed();
            let position = parseInt(block.style.bottom) || 0;
            function move() {
                if (!gameActive || currentBlock !== block) return;
                position += speed / 30;
                block.style.bottom = position + "px";
                if (position > window.innerHeight) {
                    gameOver();
                    return;
                }
                requestAnimationFrame(move);
            }
            move();
        }
        function gameOver(customMessage = null) {
            gameActive = false;
            helperActive = false;
            // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –û—á–∏—â–∞–µ–º –≤—Å–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã
            if (helperInterval) {
                clearInterval(helperInterval);
                helperInterval = null;
            }
            if (helperElement && helperElement.parentNode) {
                document.body.removeChild(helperElement);
                helperElement = null;
            }
            const sessionTime = Date.now() - gameMetrics.startTime;
            console.log('üéÆ [–ö–æ—Å–º–∏—á–µ—Å–∫–∏–π –ö–ª–∏–∫–µ—Ä] –°–µ—Å—Å–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞:', {
                session: gameMetrics.sessions,
                duration_sec: Math.round(sessionTime / 1000),
                total_damage: totalDamageDealt,
                current_location: currentLocation,
                total_coins: coins,
                blocks_destroyed: gameMetrics.blocksDestroyed,
                upgrades_bought: gameMetrics.upgradesBought,
                total_clicks: gameMetrics.totalClicks
            });
            localStorage.setItem('gameSessions', gameMetrics.sessions.toString());
            if (currentBlock && gameArea.contains(currentBlock)) {
                gameArea.removeChild(currentBlock);
                currentBlock = null;
            }
            if (finalScoreDisplay) {
                applyTranslation(finalScoreDisplay, 'gameOver.score', { damage: Math.floor(totalDamageDealt).toLocaleString() });
            }
            if (gameOverScreen) {
                gameOverScreen.style.display = "flex";
            }
            if (customMessage) {
                const h2 = gameOverScreen.querySelector('h2');
                if (h2) h2.textContent = customMessage;
            }
        }
        function shareResult() {
            const shareText = `üéÆ –Ø –Ω–∞–Ω–µ—Å ${Math.floor(totalDamageDealt).toLocaleString()} —É—Ä–æ–Ω–∞ –∏ —Å–æ–±—Ä–∞–ª ${Math.floor(coins)} –ö—Ä–∏—Å—Ç–∞–ª–ª–æ–≤ –≤ –ö–æ—Å–º–∏—á–µ—Å–∫–æ–º –ö–ª–∏–∫–µ—Ä–µ! üåå
–°–º–æ–∂–µ—à—å –ø–æ–±–∏—Ç—å –º–æ–π —Ä–µ–∫–æ—Ä–¥?`;
            if (navigator.share) {
                navigator.share({
                    title: '–ú–æ–π —Ä–µ–∫–æ—Ä–¥ –≤ –ö–æ—Å–º–∏—á–µ—Å–∫–æ–º –ö–ª–∏–∫–µ—Ä–µ!',
                    text: shareText
                }).then(() => {
                    coins += 50;
                    updateCoins();
                    updateHUD();
                    showTooltip(translations[currentLanguage].tooltips.shareSuccess);
                    setTimeout(hideTooltip, 2000);
                    saveGame();
                });
            } else {
                navigator.clipboard.writeText(shareText).then(() => {
                    alert('–†–µ–∑—É–ª—å—Ç–∞—Ç —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω! –ü–æ–¥–µ–ª–∏—Å—å —Å –¥—Ä—É–∑—å—è–º–∏!');
                    coins += 50;
                    updateCoins();
                    updateHUD();
                    saveGame();
                });
            }
        }
        function showTooltip(text) {
            if (tooltip) {
                tooltip.innerHTML = text;
                tooltip.style.opacity = "1";
            }
        }
        function hideTooltip() {
            if (tooltip) tooltip.style.opacity = "0";
        }
        // –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –°–¢–ê–†–¢–ê –ò–ì–†–´
        function startGame(reset = true) {
            if (reset) {
                // –ü–æ–ª–Ω–æ—Å—Ç—å—é —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø—Ä–∏ –Ω–∞—á–∞–ª–µ –Ω–æ–≤–æ–π –∏–≥—Ä—ã
                coins = 0;
                totalDamageDealt = 0;
                currentLocation = 'mercury';
                clickPower = 1;
                clickUpgradeLevel = 0;
                helperUpgradeLevel = 0;
                helperDamageBonus = 0.3;
                critChance = 0.001;
                critMultiplier = 2.0;
                helperActive = false;
                helperTimeLeft = 0;
                bogoCoinBonus = 0;
                // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –°–±—Ä–∞—Å—ã–≤–∞–µ–º –Ω–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
                critChanceUpgradeLevel = 0;
                critMultiplierUpgradeLevel = 0;
                // –û—á–∏—â–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–∏ –Ω–∞—á–∞–ª–µ –Ω–æ–≤–æ–π –∏–≥—Ä—ã
                localStorage.removeItem('cosmicBlocksSave');
            } else {
                // –ï—Å–ª–∏ –Ω–µ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º, –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º —É—Ä–æ–Ω –ø–æ –Ω–æ–≤–æ–π —Ñ–æ—Ä–º—É–ª–µ
                clickPower = calculateClickPower();
                // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –¥–æ–±–∞–≤–ª—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ UI –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
                updateHUD();
                updateProgressBar();
                updateUpgradeButtons();
            }
            // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –û—á–∏—â–∞–µ–º –≤—Å–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã
            if (helperInterval) {
                clearInterval(helperInterval);
                helperInterval = null;
            }
            if (helperElement && helperElement.parentNode) {
                document.body.removeChild(helperElement);
                helperElement = null;
            }
            gameArea.innerHTML = "";
            if (welcomeScreen) {
                welcomeScreen.style.display = "none";
            }
            if (saveScreen) {
                saveScreen.style.display = "none";
            }
            if (gameOverScreen) {
                gameOverScreen.style.display = "none";
            }
            gameActive = true;
            comboCount = 0;
            lastDestroyTime = 0;
            gameMetrics.startTime = Date.now();
            gameMetrics.blocksDestroyed = 0;
            gameMetrics.upgradesBought = 0;
            gameMetrics.totalClicks = 0;
            updateCoins();
            updateHUD();
            updateProgressBar();
            updateUpgradeButtons();
            setLocation(currentLocation);
            setTimeout(() => createMovingBlock(), 500);
        }
        function continueGame() {
            if (loadGame()) {
                startGame(false); // –ù–µ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
            } else {
                showTooltip(translations[currentLanguage].tooltips.noSave);
                setTimeout(hideTooltip, 2000);
            }
        }
        function showSaveScreen() {
           if (saveScreen) {
                saveScreen.style.display = "flex";
            }
        }
        function restartGame() {
            startGame(true); // –ü–æ–ª–Ω–æ—Å—Ç—å—é —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –∏–≥—Ä—É
        }
        function showStartError() {
            showTooltip("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∏–≥—Ä—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É.");
            setTimeout(hideTooltip, 3000);
        }
        // === –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–ë–´–¢–ò–ô ===
        if (langBtnWelcome) {
            langBtnWelcome.addEventListener('click', switchLanguage);
            langBtnWelcome.addEventListener('touchstart', function(e) {
                e.preventDefault();
                switchLanguage();
            }, { passive: false });
        }
        if (startBtn) {
            startBtn.addEventListener('click', function() {
                try {
                    showSaveScreen();
                } catch (error) {
                    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∏–≥—Ä—ã:", error);
                    showStartError();
                }
            });
            startBtn.addEventListener('touchstart', function(e) {
                e.preventDefault();
                try {
                    showSaveScreen();
                } catch (error) {
                    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∏–≥—Ä—ã:", error);
                    showStartError();
                }
            }, { passive: false });
        }
        if (continueBtn) {
            continueBtn.addEventListener('click', function() {
                try {
                    const hasSave = localStorage.getItem('cosmicBlocksSave') !== null;
                    if (hasSave) {
                        showSaveScreen();
                    } else {
                        showTooltip(translations[currentLanguage].tooltips.noSave);
                        setTimeout(hideTooltip, 2000);
                    }
                } catch (error) {
                    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–∏ –∏–≥—Ä—ã:", error);
                    showStartError();
                }
            });
            continueBtn.addEventListener('touchstart', function(e) {
                e.preventDefault();
                try {
                    const hasSave = localStorage.getItem('cosmicBlocksSave') !== null;
                    if (hasSave) {
                        showSaveScreen();
                    } else {
                        showTooltip(translations[currentLanguage].tooltips.noSave);
                        setTimeout(hideTooltip, 2000);
                    }
                } catch (error) {
                    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–∏ –∏–≥—Ä—ã:", error);
                    showStartError();
                }
            }, { passive: false });
        }
        if (loadSaveBtn) {
            loadSaveBtn.addEventListener('click', continueGame);
            loadSaveBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                continueGame();
            }, { passive: false });
        }
        if (newGameBtn) {
            newGameBtn.addEventListener('click', () => startGame(true));
            newGameBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startGame(true);
            }, { passive: false });
        }
        if (cancelSaveBtn) {
            cancelSaveBtn.addEventListener('click', () => {
                if (saveScreen) saveScreen.style.display = "none";
            });
            cancelSaveBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (saveScreen) saveScreen.style.display = "none";
            }, { passive: false });
        }
        function addMobileButtonHandlers(button, handler) {
            if (button) {
                button.addEventListener('click', handler);
                button.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    handler();
                }, { passive: false });
            }
        }
        addMobileButtonHandlers(upgradeClickBtn, buyClickPower);
        addMobileButtonHandlers(upgradeHelperBtn, buyHelper);
        addMobileButtonHandlers(upgradeCritChanceBtn, buyCritChance);
        addMobileButtonHandlers(upgradeCritMultBtn, buyCritMultiplier);
        addMobileButtonHandlers(upgradeHelperDmgBtn, buyHelperDamage);
        if (upgradeClickBtn) {
            upgradeClickBtn.addEventListener('mouseenter', () => showTooltip(translations[currentLanguage].tooltips.upgradeClick));
            upgradeClickBtn.addEventListener('mouseleave', hideTooltip);
        }
        if (upgradeHelperBtn) {
            upgradeHelperBtn.addEventListener('mouseenter', () => showTooltip(translations[currentLanguage].tooltips.upgradeHelper));
            upgradeHelperBtn.addEventListener('mouseleave', hideTooltip);
        }
        if (upgradeCritChanceBtn) {
            upgradeCritChanceBtn.addEventListener('mouseenter', () => showTooltip(translations[currentLanguage].tooltips.upgradeCritChance));
            upgradeCritChanceBtn.addEventListener('mouseleave', hideTooltip);
        }
        if (upgradeCritMultBtn) {
            upgradeCritMultBtn.addEventListener('mouseenter', () => showTooltip(translations[currentLanguage].tooltips.upgradeCritMult));
            upgradeCritMultBtn.addEventListener('mouseleave', hideTooltip);
        }
        if (upgradeHelperDmgBtn) {
            upgradeHelperDmgBtn.addEventListener('mouseenter', () => showTooltip(translations[currentLanguage].tooltips.upgradeHelperDmg));
            upgradeHelperDmgBtn.addEventListener('mouseleave', hideTooltip);
        }
        addMobileButtonHandlers(restartBtn, restartGame);
        addMobileButtonHandlers(shareBtn, shareResult);
        if (saveBtn) {
            saveBtn.addEventListener('click', saveGame);
            saveBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                saveGame();
            }, { passive: false });
        }
        // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
        updateCoins();
        updateHUD();
        updateProgressBar();
        setLocation(currentLocation);
        // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ö–ù–û–ü–ö–ò –°–ú–ï–ù–´ –Ø–ó–´–ö–ê
        updateLanguageFlag();
        updateLangButtonTooltip();
        // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –í—ã–∑–æ–≤ updateContinueButton –ø–æ—Å–ª–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –≤—Å–µ—Ö —Ñ—É–Ω–∫—Ü–∏–π
        updateContinueButton();
        // –ü—Ä–∏–º–µ–Ω—è–µ–º –ø–µ—Ä–µ–≤–æ–¥—ã –ø–æ—Å–ª–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
        updateAllTranslations();
        // –°–ª—É—à–∞—Ç–µ–ª—å —Å–æ–±—ã—Ç–∏–π –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
        window.addEventListener('resize', function() {
            if (helperElement) {
                moveHelperToRandomPosition();
            }
        });
    });
    // –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –∂–µ—Å—Ç–æ–≤ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –≤—ã–¥–µ–ª–µ–Ω–∏—è
    document.addEventListener('touchstart', function(e) {
        if (e.touches.length > 1) {
            e.preventDefault();
        }
    }, { passive: false });
    document.addEventListener('gesturestart', function(e) {
        e.preventDefault();
    }, { passive: false });
    document.addEventListener('gesturechange', function(e) {
        e.preventDefault();
    }, { passive: false });
    document.addEventListener('gestureend', function(e) {
        e.preventDefault();
    }, { passive: false });
  </script>
<link rel="stylesheet" href="shop.css">
<script src="shop.js" defer></script>
<link rel="stylesheet" href="achievements.css">
<script src="achievements.js" defer></script>
</body>
</html>